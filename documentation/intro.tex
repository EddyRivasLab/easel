\section{Overview of modules}
\begin{tabular}{llll}\hline
\textbf{Module} & \textbf{Description}       & \textbf{Requires} & \textbf{Augmentation(s)}\\\hline
  \multicolumn{4}{c}{\textbf{Core module}}\\
easel           & Framework for using Easel         &  -     & \\
  \multicolumn{4}{c}{\textbf{Foundation modules}}\\
alphabet        & Digitized biosequence alphabets   & easel  & \\
dmatrix         & Matrix algebra                    & easel  & \\ 
fileparser      & Token-based data file input       & easel  & \\
getopts         & Command line parsing              & easel  & \\
keyhash         & Keyword hashing                   & easel  & \\
msa             & Multiple sequence alignment i/o   & easel  & keyhash \\
random          & Random number generator           & easel  & \\
regexp          & Regular expression matching       & easel  & \\
sqio            & Sequence file i/o                 & easel  & alphabet, msa\\
stack           & Pushdown stacks                   & easel  & \\
vectorops       & Vector operations                 & easel  & \\\hline
  \multicolumn{4}{c}{\textbf{Derived modules}}\\
bioparse\_paml  & PAML rate matrix datafiles        & easel dmatrix parse & \\
dirichlet       & Dirichlet densities               & easel vectorops  & fileparser, random \\ 
ratematrix      & Evolutionary rate matrices        & easel dmatrix vectorops & \\
wuss            & RNA structure annotation          & easel stack    & \\\hline
  \multicolumn{4}{c}{\textbf{Optional library interfaces}}\\
interface\_gsl    & GNU Scientific Library          & easel dmatrix & \\
interface\_lapack & LAPACK linear algebra library   & easel dmatrix & \\\hline
\end{tabular}



\section{Overview of data structures}

\begin{tabular}{lll}\hline
\textbf{Object}          & \textbf{Implemented in} & \textbf{Description}\\\hline
\ccode{ESL\_ALPHABET}    & \cfile{alphabet}        & Digitized sequence alphabet\\
\ccode{ESL\_DMATRIX}     & \cfile{dmatrix}         & 2D double-precision matrix for linear algebra \\
\ccode{ESL\_FILEPARSER}  & \cfile{fileparser}      & Token-based input file parser\\
\ccode{ESL\_GETOPTS}     & \cfile{getopts}         & Application configuration state\\
\ccode{ESL\_KEYHASH}     & \cfile{keyhash}         & Keyword hash table\\
\ccode{ESL\_MIXDCHLET}   & \cfile{dirichlet}       & Mixture Dirichlet prior\\
\ccode{ESL\_MSA}         & \cfile{msa}             & Multiple sequence alignment\\
\ccode{ESL\_MSAFILE}     & \cfile{msa}             & Multiple sequence alignment file parser\\
\ccode{ESL\_PERMUTATION} & \cfile{dmatrix}         & Permutation matrix used in linear algebra\\
\ccode{ESL\_RANDOMNESS}  & \cfile{random}          & Random number generator\\
\ccode{ESL\_REGEXP}      & \cfile{regexp}          & Regular expression pattern-matching machine\\
\ccode{ESL\_SEQFILE}     & \cfile{sqio}            & Biosequence file parser (unaligned)\\
\ccode{ESL\_SQ}          & \cfile{sqio}            & DNA/RNA/protein sequence data\\
\ccode{ESL\_STACK}       & \cfile{stack}           & Pushdown stack\\\hline
\end{tabular}

\section{Module design}

Easel is designed to be used in two different ways: as a C library
(\ccode{libeasel.a}) in the usual C way, or by grabbing individual
source files without the rest of the library.

The ability to borrow individual files from Easel makes it different
from many other C libraries. For example, to get Easel's sequence file
i/o API, for example, you just take the sqio module (the C source
\ccode{esl\_sqio.c} and the header \ccode{esl\_sqio.h}), plus the
obligatory Easel core (\ccode{easel.c} and \ccode{easel.h}). Most of
Easel's modules can stand alone in this way (the \emph{base}
modules). Only a few are dependent on other modules (the
\emph{derived} modules), though even these can be used just by
bringing along the modules they depend on.

There are a couple of reasons to provide standalone capability. One
reason came from teaching a computational molecular biology
course. For homework programming assignments, I wanted to provide
students with simple .c files with well-documented APIs for routine
things like sequence i/o. This was to give them a head start, save
them from implementing boring things, and let them concentrate on
learning algorithms. But at the same time, I wanted them to be able to
see where the functionality was coming from, and to study the .c files
if they wanted, rather than treating the library as a black box -- so
I wanted to give them a few .c files at a time, not a library.

A second reason comes from my frustration with C libraries and code
reuse in bioinformatics in general. If I want to take a single routine
from someone's library (say, gods help us, the NCBI Toolkit), it's
common that that routine has dependencies, and the dependencies have
dependencies, and pretty soon I'm dragging the whole damned library in
just to have access to the routine I wanted. I don't mind that in
standard, widely installed system libraries, but if I'm making a
robustly distributable bioinformatics application, I need to include
in my package all my nonstandard dependencies -- and I really don't
want to have to distribute the entire GNU Scientific Library just to
pick up two GSL functions, all of LAPACK to get one numerical routine,
and the whole NCBI Toolkit to pick up one Toolkit routine.

Thus, Easel is very strictly modular in design. You never need the
entire Easel library to use any one aspect of Easel's
functionality. Most often, you need only the module you're interested
in, plus the core easel module.

To facilitate code reuse, Easel is licensed under a permissive open
source license (the Creative Commons Attribution License) that allows
you to freely modify and redistribute the code.

In the end, some of my original intent of providing simple
implementations as teaching examples has been lost. Rather than
providing two implementations (my intended simple teaching example and
a full-strength production example), Easel code is all production
code. But the modularity remains, and it seems to be useful in other
respects.  Modular design is just a Good Thing in general.  Easel
modules can be unit-tested in absence of the rest of the library.
And, though this remains to be seen, it should be easy for other
people to contribute modules and extend Easel, and it should be easy
for people to borrow and reuse Easel code.

\section{The ``augmentation'' concept}

The trouble with enforcing strict modular design is that while
\emph{you} (the application writer) can take advantage of any or all
of Easel's functionality as you wish, \emph{Easel} can't. An Easel
module, by design, is as isolated as possible from all other Easel
modules. It shouldn't use any functionality other than the essentials
in the core \eslmod{easel} module. But what if module X would benefit
from the cool features of module Y -- for instance, what if we want
the \eslmod{sqio} sequence i/o module to have access to the fast file
indexing capabilities of the \eslmod{ssi} module?  Start down this
road, and pretty soon the library is full of dependencies, the modular
design collapses, and we're back to a standard all-or-none C library.

Easel introduces a concept called \emph{augmentation}. The base
functionality of many Easel modules can be optionally \emph{augmented}
by one or more other Easel modules. An augmentation confers optional
powers on a module beyond its default standalone behavior.

Sometimes, an augmentation adds new functions to a module's API.  For
example, \eslmod{alphabet} augmentation of the sequence i/o module
\eslmod{sqio} adds a function to the \eslmod{sqio} API for digitizing
a sequence.

Sometimes, an augmentation extends or generalizes the scope of one or
more functions in the API. For instance, augmenting the \eslmod{sqio}
module with \eslmod{msa} gives the ability to read alignment files as
if they were sequential, unaligned sequence databases through
\eslmod{sqio}'s existing API.

And sometimes, an augmentation invisibly makes existing functions
faster or more memory-efficient, without adding any new functionality
per se.  For example, \eslmod{msa} can be augmented by
\eslmod{keyhash}, which makes the \eslmod{msa} module capable of
handling much larger alignments more efficiently than it does by
default, because \eslmod{keyhash} gives it the ability to use fast
hashing methods in its parsers.

When Easel is installed as a library, all modules are fully
augmented. This is done when the library is compiled. The
\ccode{configure} script automatically enables all augmentations when
it sets up the \ccode{easel.h} header, before compiling and installing
the library.

When you borrow an individual module from Easel, you choose whether to
borrow any modules that augment it. To activate an augmentation, you
not only have to compile and link the C code for the extra module
(obviously), you also edit a line in the \ccode{easel.h} header file
before compilation. There is a section at the top of \ccode{easel.h}
that declares which augmentations are to be enabled. You
\ccode{\#define} the appropriate flag for your augmentation to
activate it; for instance, to augment with \eslmod{ssi}, you make sure
\ccode{easel.h} has a line \ccode{\#define eslAUGMENT\_SSI} in place
of \ccode{\#undef eslAUGMENT\_SSI}.

Documentation for modules and their functions always distinguishes
between default functionality and augmented functionality.

\section{Function naming conventions in Easel}

\subsection{Object creation, initialization, destruction}

Most of Easel's objects are allocated on the heap; that is, accessed
exclusively via pointers. Less often, routines may allow an object to
be allocated on the stack.

\begin{sreitems}{\ccode{Create,Destroy}}
\item [\ccode{Create,Destroy}] 
  \ccode{esl\_foo\_Create()} allocates and initializes a new \ccode{ESL\_FOO}
  object, returning a pointer to the new
  object. The \ccode{Create()} function is passed any necessary
  initialization or size information in its arguments.
  \ccode{esl\_foo\_Destroy(obj)} frees all the memory associated
  with a \ccode{ESL\_FOO} object,  given a pointer to the object,
  and returns \ccode{ESL\_OK}. Example:

\begin{cchunk}
ESL_SQ *sq;

sq = esl_sq_Create();
esl_sq_Destroy(sq);
\end{cchunk}
  
\item [\ccode{Open,Close}] 
  Same as \ccode{Create()} and \ccode{Destroy()}, but specifically for
  objects associated with input/output streams. Example:

\begin{cchunk}
char        *seqfile = ``foo.seq'';
ESL_SIO     *sqfp;

sqfp = esl_sio_Open(seqfile);
esl_sio_Close(sqfp);
\end{cchunk}


\item [\ccode{Inflate,Deflate}]
  \ccode{esl\_foo\_Inflate(\&obj)} takes a pointer to the ``shell'' of an
  \ccode{ESL\_FOO} object that has been allocated on the stack, and
  allocates and initializes all the internals of it. The
  \ccode{Inflate()} function is passed any necessary initialization or
  size information in its arguments.  \ccode{esl\_foo\_Deflate(\&obj)}
  frees all the internal memory associated with a \ccode{ESL\_FOO} object,
  given a pointer to the object, but the object shell is left alone.
  The only difference between \ccode{Create,Destroy} and
  \ccode{Inflate,Deflate} is whether the object shell itself is to be
  allocated, or not. Example:

\begin{cchunk}
ESL_SQ  sq;

esl_sq_Inflate(&sq);
esl_sq_Deflate(&sq);
\end{cchunk}



\item [\ccode{Expand,Squeeze}]
   These deal with objects whose contents are not necessarily of a
   fixed size, but can grow and require reallocation of internal data
   fields. A function \ccode{esl\_foo\_Expand()} reallocates an
   \ccode{ESL\_FOO} object to a larger size. Usually, reallocation
   works by doubling the previous allocation. The redoubling strategy
   can result in a fair amount of unused memory overhead (up to
   50\%). A function \ccode{esl\_foo\_Squeeze()} takes a fully-grown
   object and optimizes its memory usage, recovering this wastage
   overhead, on the assumption that no more reallocation will be
   done.



\item [\ccode{Reuse}] 
   \ccode{esl\_foo\_Reuse(obj)} reinitializes an object exactly as a
   \ccode{Create} or \ccode{Inflate} function would initialize it, \emph{without}
   allocating new memory; it reuses memory that has
   already been allocated when the object was originally created or
   inflated. For some objects that are used sequentially (like,
   sequences), reusing one object saves malloc()'s compared to
   lots of Create/Destroy calls. A \ccode{Reuse} function does not
   care whether the object was originally created by a \ccode{Create}
   or a \ccode{Inflate} call. Example:

\begin{cchunk}
ESL_SQ *sq;

sq = esl_sq_Create();
  /* read a sequence into the sq object, have fun with it */

esl_sq_Reuse(sq);
  /* read a second sequence into it */

esl_sq_Destroy(sq);
\end{cchunk}

\end{sreitems}

\subsection{Other common object manipulation functions}

\begin{sreitems}{\ccode{\_Copy(src, dest)}}

\item[\ccode{\_Copy(src, dest)}]
Copies \ccode{src} object into \ccode{dest}, where the caller has
already created the empty \ccode{dest} object. Returns \ccode{ESL\_OK}
on success; throws \ccode{ESL\_EINCOMPAT} if the objects are not
compatible (for example, two matrices that are not the same size).

The order of the arguments is always \ccode{src} $\rightarrow$
\ccode{dest} (unlike the C library's \ccode{strcpy()} convention, which
is the opposite order).

\item[\ccode{\_Duplicate(obj)}] 

Creates and returns a pointer to a duplicate of \ccode{obj}.
Equivalent to (and is a shortcut for) \ccode{dest = \_Create();
\_Copy(src, dest)}. Caller is responsible for free'ing the duplicate
object, just as if it had been \ccode{\_Create}'d. Throws NULL if
allocation fails.

\item[\ccode{\_Set*(obj, value...)}]

Initializes value(s) in \ccode{obj} to \ccode{value}. Special cases of
\ccode{\_Set*} functions may exist, like \ccode{\_SetZero} (set to
zero(s)), or \ccode{esl\_dmatrix\_SetIdentity} (set a dmatrix to an
identity matrix).

\end{sreitems}


\section{Discipline of writing Easel modules}


\subsection{API}

\begin{enumerate}
\item Exposed function names obey Easel conventions.

\item All \ccode{ret\_*} pointers for retrieving info from 
      a function are implemented as optional.

\item On any error (returned or thrown), a function releases any
      memory it has allocated, and all \ccode{ret\_*} pointers are
      \ccode{NULL} or 0, depending on their type.

\item Any function that calls another Easel function must 
      catch any thrown errors. Within Easel, we
      can't assume that the error handler is set to be a fatal
      one.
\end{enumerate}


\subsection{Documentation}

\begin{enumerate}
\item Documentation in .tex files is written to application developers
      (and me); documentation in .c comments is written to Easel
      developers (and me).

\item Every module has a .tex file documenting the module and its API,
      and (if it makes sense) also the particular implementation.

\item Every function exposed to the API can be autodocumented (comment
      header can be converted to \LaTeX) with
      \ccode{autodoc\_functions}, in order to produce appendices
      summarizing the complete Easel function set.
\end{enumerate}


\subsection{Testing}

\begin{enumerate}

\item Every module has a test driver which exercises the API in some
      simple way (and, in the process, provides a ``hello world''
      level example of using the module).

\end{enumerate}











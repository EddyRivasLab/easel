



Easel is a C code library for bioinformatics applications.  Some of
the Eddy lab's software packages depend on Easel, including HMMER and
Infernal, the software engines that the Pfam and Rfam protein and RNA
family databases rely on. Easel organizes a body of my work in what I
hope is a useful form, so that new people in my lab can avoid
reinventing the wheel as many times as I have. Perhaps it will also be
useful to you.

Easel's documentation includes tutorial examples to make it easy to
get started with any given Easel module. Easel is modular, to help you
extract individual files or functions for use in your own code,
without having to disentangle the entire library. Easel is freely
distributed as open source so that you can use and modify it for
anything, including commercial purposes.

\section{Quick start}

Let's assume you just want to take a quick tour, because you're
deciding whether Easel is useful or not. You can compile Easel and try
it out without installing it. 

After you obtain an Easel source tarball (from
\url{http://selab.janelia.org/easel}, for example), it should compile
out of the box on any UNIX, Linux, or Mac OS/X operating
system\footnote{You need a C compilation environment, which you might
not have. If not, install a C compiler first, such as the free GNU gcc
compiler, or see your local system guru.} with this incantation
(where \ccode{xxx} is a version number):

\begin{cchunk}
% tar zxf easel-xxx.tar.gz
% cd easel-xxx
% ./configure
% make
% make check
\end{cchunk}

The \ccode{make check} command is optional. It runs a battery of
quality control tests. All of these should pass. You should now see
\ccode{libeasel.a} in the directory.

Every source code module (that is, each \ccode{.c} file) ends with one
or more \esldef{driver programs}, including programs for unit tests
and benchmarks. These are \ccode{main()} functions that can be
conditionally included when the module is compiled. Among them is
always at least one \esldef{example driver} that shows you how to use
the module. You can find the example code in a module \eslmod{foo} by
searching the \ccode{esl\_foo.c} file for the tag
\ccode{eslFOO\_EXAMPLE}. To compile the example for module
\eslmod{foo} as a working program, do:

\begin{cchunk}
   % cc -o example -L. -I. -DeslFOO_EXAMPLE esl_foo.c -leasel -lm
\end{cchunk}

You might need to replace the standard \ccode{cc} with a different
compiler name, depending on your system. Linking to the standard math
library (\ccode{-lm}) may not be necessary, depending on what module
you're compiling, but it won't hurt. Replace \ccode{foo} with the name
of a module you want to play with, and you can compile any of Easel's
example drivers this way.

To run it, read the source code to see if it needs any command line
arguments, like the name of a file to open, then:

\begin{cchunk}
   % ./example <any args needed>
\end{cchunk}

You can edit the example driver to play around with it, if you like,
but it's better to make a copy of it in your own file (say,
\ccode{foo\_example.c}) so you're not changing Easel's code. When you
extract the code into a file, copy what's between the \ccode{\#ifdef
eslFOO\_EXAMPLE} and \ccode{\#endif /*eslFOO\_EXAMPLE*/} flags that
conditionally include the example driver (don't copy the flags
themselves).  Compile your example code like this:

\begin{cchunk}
   % cc -o foo_example -L. -I. foo_example.c esl_foo.c -leasel -lm
\end{cchunk}

That's it. Now you can compile Easel-based programs that you can
modify and play around with. If you're the type (like me) that learns
best by example, you're on your way. The next section (below) will
introduce the different modules in Easel, so you can see what you
might be interested in. When you want to know more about a module,
either check that module's chapter in this guide, or just read the
module's source code. Most of the documentation is compiled
automatically from the source code comments anyway.

If you decide you want to install Easel permanently, see the full
installation instructions in chapter~\ref{chapter:installation}.

\section{Overview of Easel's modules}

Each \ccode{.c} file in Easel corresponds to one Easel \esldef{module}.
A module consists of a group of functions for some
task. Table~\ref{tbl:module_list} shows a list of all the modules. For
example, the \eslmod{sqio} module can automatically parse many common
unaligned sequence formats, and the \eslmod{msa} module can parse many
common multiple alignment formats.

% documentation/esl-depends.pl
% can autoextract the module dependencies, including augmentations,
% but this table seems to work best as a simple list of modules.
%
\begin{table}
\begin{center}
\begin{tabular}{lll}\hline
\textbf{Module} & \textbf{Description} \\
  \multicolumn{2}{c}{\textbf{Foundation:}}\\
%
\eslmod{easel}           & Framework for using Easel & \\
%
  \multicolumn{2}{c}{\textbf{Core modules:}}\\
%
\eslmod{alphabet}        & Digitized biosequence alphabets        \\
\eslmod{dmatrix}         & Matrix algebra                         \\
\eslmod{fileparser}      & Input of simple token-based data files \\
\eslmod{getopts}         & Command line parsing                   \\
\eslmod{keyhash}         & Keyword hashing                        \\
\eslmod{msa}             & Multiple sequence alignment i/o        \\
\eslmod{random}          & Random number generator                \\
\eslmod{regexp}          & Regular expression matching            \\
\eslmod{sqio}            & Sequence file i/o                      \\
\eslmod{ssi}             & Indices for large sequence files       \\
\eslmod{stack}           & Pushdown stacks                        \\
\eslmod{stats}           & Foundation for statistics group        \\
\eslmod{stopwatch}       & Timing parts of programs               \\
\eslmod{vectorops}       & Vector operations                      \\
%
  \multicolumn{2}{c}{\textbf{Numerical computing group:}}\\
%
\eslmod{minimizer}       & Multidimensional optimization          \\
%
  \multicolumn{2}{c}{\textbf{Phylogeny group:}}\\
%
\eslmod{tree}         & Phylogenetic trees                   \\
\eslmod{distance}     & Phylogenetic distance calculations   \\
%
  \multicolumn{2}{c}{\textbf{Statistics group:}}             \\
%
\eslmod{histogram}    & Collecting/fitting data histograms   \\
\eslmod{dirichlet}    & Dirichlet densities.                 \\
\eslmod{exponential}  & Exponential densities.               \\
\eslmod{gamma}        & Gamma densities.                     \\
\eslmod{gev}          & Generalized extreme value (GEV) densities \\
\eslmod{gumbel}       & Gumbel densities.                    \\
\eslmod{hyperexp}     & Hyperexponential densities.          \\
\eslmod{mixdchlet}    & Mixture Dirichlet densities.         \\
\eslmod{mixgev}       & Mixture GEV densities.              \\
\eslmod{stretchexp}   & Stretched exponential densities.    \\
\eslmod{weibull}      & Weibull densities.                  \\
%
  \multicolumn{2}{c}{\textbf{Miscellaneous:}}\\
\eslmod{bioparse\_paml}  & PAML rate matrix datafiles        \\
\eslmod{ratematrix}      & Evolutionary rate matrices        \\
\eslmod{wuss}            & RNA structure annotation          \\
%
  \multicolumn{2}{c}{\textbf{Optional library interfaces:}}\\
%
interface\_gsl    & GNU Scientific Library          \\
interface\_lapack & LAPACK linear algebra library   \\
\hline
\end{tabular}
\end{center}
\caption{Overview of Easel's modules.}
\label{tbl:module_list}
\end{table}

Though you would normally use Easel as a C library
(\ccode{libeasel.a}) that you link with your code, Easel is also
designed to be sufficiently modular that you can grab individual
source files out of the library and use them directly in your own
code. For example, to get Easel's sequence file i/o API, for example,
you can take the sqio module (the C source \ccode{esl\_sqio.c} and the
header \ccode{esl\_sqio.h}), plus the obligatory Easel core
(\ccode{easel.c} and \ccode{easel.h}). Many of Easel's modules are
free-standing, and only depend on the foundation \eslmod{easel}
module. Some modules require a few other modules, but the total number
of modules you have to take to get any particular Easel API is always
small. Each module's documentation shows its required dependencies.

To minimize the number of modules you need to take to get some part of
Easel into your code, Easel uses a concept it calls
\emph{augmentation}. Each module provides a base functionality that is
as simple as possible, and which depends on as few other modules as
possible. When more powerful functionality would require additional
modules, where possible, Easel isolates that functionality and makes
it optional. You can \emph{augment} the module and activate these more
powerful optional abilities by providing the appropriate modules, or
you can leave the optional modules out.  For example, if you use only
the \eslmod{sqio} module, you get the ability to read unaligned
sequence files like FASTA or Genbank; but if you augment \eslmod{sqio}
with the \eslmod{msa} multiple alignment module, you gain the ability
to read individual sequences from multiple alignment files
sequentially. At compile-time, you declare (by means of
\ccode{\#define} flags in \ccode{easel.h}) what modules you've taken,
which defines what augmentations are possible. Each module's
documentation shows what optional augmentations are activated by other
modules. Of course, when Easel is used as a complete
\ccode{libeasel.a} library, all modules are fully augmented.




Many modules are organized around one or a few ``objects'' (usually a
C structure). Table~\ref{tbl:object_list} shows an overview of the
objects you might use (there are a few more objects that are used
internally). This quasi-object-orientation is used to simplify the
code design, focusing each module around a common datatype. 

\begin{table}
\begin{tabular}{lll}\hline
\textbf{Object}          & \textbf{Implemented in} & \textbf{Description}\\\hline
\ccode{ESL\_ALPHABET}    & \eslmod{alphabet}        & Digitized sequence alphabet\\
\ccode{ESL\_DMATRIX}     & \eslmod{dmatrix}         & 2D double-precision matrix for linear algebra \\
\ccode{ESL\_FILEPARSER}  & \eslmod{fileparser}      & Token-based input file parser\\
\ccode{ESL\_GETOPTS}     & \eslmod{getopts}         & Application configuration state\\
\ccode{ESL\_HISTOGRAM}   & \eslmod{histogram}       & Collecting/fitting data histograms\\
\ccode{ESL\_HYPEREXP}    & \eslmod{hyperexp}        & Hyperexponential distribution\\
\ccode{ESL\_KEYHASH}     & \eslmod{keyhash}         & Keyword hash table\\
\ccode{ESL\_MIXDCHLET}   & \eslmod{dirichlet}       & Mixture Dirichlet prior\\
\ccode{ESL\_MIXGEV}      & \eslmod{mixgev}          & Mixture generalized EVD\\
\ccode{ESL\_MSA}         & \eslmod{msa}             & Multiple sequence alignment\\
\ccode{ESL\_MSAFILE}     & \eslmod{msa}             & Multiple sequence alignment file parser\\
\ccode{ESL\_NEWSSI}      & \eslmod{ssi}             & New SSI index being created\\
\ccode{ESL\_OPTIONS}     & \eslmod{getopts}         & Configuration of a command-line option\\
\ccode{ESL\_PERMUTATION} & \eslmod{dmatrix}         & Permutation matrix used in linear algebra\\
\ccode{ESL\_RANDOMNESS}  & \eslmod{random}          & Random number generator\\
\ccode{ESL\_REGEXP}      & \eslmod{regexp}          & Regular expression pattern-matching machine\\
\ccode{ESL\_SQ}          & \eslmod{sqio}            & DNA/RNA/protein sequence data\\
\ccode{ESL\_SQFILE}      & \eslmod{sqio}            & Biosequence file parser (unaligned)\\
\ccode{ESL\_SSI}         & \eslmod{ssi}             & An SSI index being used\\
\ccode{ESL\_STACK}       & \eslmod{stack}           & Pushdown stack\\
\ccode{ESL\_STOPWATCH}   & \eslmod{stopwatch}       & Timer for parts of a program\\
\hline
\end{tabular}
\caption{Overview of Easel's objects.}
\label{tbl:object_list}
\end{table}

A pitfall of putting data into complex, custom datatypes is that this
can impede code reuse. You don't want to understand what's in someone
else's object, and you probably have your own favorite ways of
organizing data.  Easel assumes you are only going to use Easel
objects to call Easel functions, so you will build simple interfaces
to exchange data between your code and Easel. Thus, there are always
obvious ways to create new Easel objects from elemental data types,
and to extract elemental data types from Easel objects. Easel objects
are translucent, if not transparent; often, some of their internal
data fields are stable and documented, and you are encouraged to reach
into an object and access elemental data directly.




\section{Interfaces and design patterns}

Emerson said ``a foolish consistency is the hobgoblin of little
minds''. Easel, like Emerson, is not overly concerned with
consistency. However, similar functions are channeled towards common
design patterns, called \esldef{interfaces}, that are guidelines for a
shared behavior and a shared naming convention. Reuse of design
patterns helps Easel follow certain best practices that may be the
result of hard-won experience. Shared interface designs also help
reduce the apparent complexity of the library, by making many
functions behave in predictable ways, so it is easier to learn to use
new Easel modules. Many of Easel's functions follow interface
guidelines.

Most Easel functions have three part names like
\ccode{esl\_foo\_BarBaz()}, where the \ccode{esl} prefix defines an
Easel-specific namespace (to keep Easel functions from clashing with
the names of an application's functions), \ccode{foo} is the
lower-case base name of the Easel object that is acted on (or the
module that this function is in), and \ccode{BarBaz()} describes what
the function does.  If there are two or more functions
\ccode{esl\_foo\_BarBaz()}, \ccode{esl\_bar\_BarBaz()}, etc., then we
can talk about the \ccode{\_BarBaz()} interface. 

Conversely, if there is a \ccode{\_BarBaz()} interface, then any
function named something like \ccode{esl\_foo\_BarBaz()} or
\ccode{esl\_foo\_BarBazQux()} follows it. For example,
\ccode{esl\_sq\_Create()} is going to create a \ccode{ESL\_SQ}
sequence object, following interface guidelines for \ccode{\_Create()}
functions.

\subsection{Creating and destroying new objects}

Most Easel objects are allocated and free'd by
\ccode{\_Create()/\_Destroy()} interface. Creating an object often
just means allocating space for it, so that some other routine can
fill data into it. It does not necessarily mean that the object
contains valid data.

In summary:

\begin{sreapi}
\hypertarget{ifc:Create} 
{\item[\_Create(N)]}

A \ccode{\_Create()} interface takes any necessary initialization or
size information as arguments (there may not be any), and it returns a
pointer to the newly allocated object. If an (optional) number of
elements \ccode{N} is provided, this specifies the number of elements
that the object is going to contain (thus, creating a fixed-size
object; contrast the \ccode{\_CreateGrowable()} interface).  In the
event of any failure, the procedure throws \ccode{NULL}.

\hypertarget{ifc:Destroy} 
{\item[\_Destroy(obj)]}
A \ccode{\_Destroy()} interface takes an object pointer as an
argument, and frees all the memory associated with it.
\end{sreapi}

For example:
\begin{cchunk}
   ESL_SQ *sq;
   sq = esl_sq_Create();
   esl_sq_Destroy(sq);
\end{cchunk}



\subsubsection{Open input streams}

Some objects (such as \ccode{ESL\_SQFILE} and \ccode{ESL\_MSAFILE})
correspond to open input streams -- usually an open file, but possibly
reading from a pipe. Such objects are \ccode{\_Open()}'ed and
\ccode{\_Close()'d}, not created and destroyed.

Input stream objects have to be capable of handling normal failures,
because of bad user input. Input stream objects contain an
\ccode{errbuf[eslERRBUFSIZE]} field to capture informative parse error
messages. 

In summary:

\begin{sreapi}
\hypertarget{ifc:Open} 
{\item[\_Open(file, formatcode, \&ret\_obj)]}

Opens the \ccode{file}, which is in a format indicated by
\ccode{formatcode} for reading; return the open input object in
\ccode{ret\_obj}. A \ccode{formatcode} of 0 typically means unknown,
in which case the \ccode{\_Open()} procedure attempts to autodetect
the format. If the \ccode{file} is \ccode{"-"}, the object is
configured to read from the \ccode{stdin} stream instead of opening a
file. If the \ccode{file} ends in a \ccode{.gz} suffix, the object is
configured to read from a pipe from \ccode{gzip -dc}. Returns
\ccode{eslENOTFOUND} if \ccode{file} cannot be opened, and
\ccode{eslEFORMAT} if autodetection is attempted but the format cannot
be determined.

\hypertarget{ifc:Close} 
{\item[\_Close(obj)]}

Closes the input stream \ccode{obj}. Returns \ccode{void}.
\end{sreapi}


For example:

\begin{cchunk}
    char        *seqfile = "foo.fa";
    ESL_SQFILE  *sqfp;

    esl_sqio_Open(seqfile, eslSQFILE_FASTA, NULL, &sqfp);
    esl_sqio_Close(sqfp);
\end{cchunk}



\subsubsection{Growable objects}

Some objects need to be reallocated and expanded during their use.
These objects are called \esldef{growable}.

In some cases, the whole purpose of the object is to have elements
added to it, such as \ccode{ESL\_STACK} (pushdown stacks) and
\ccode{ESL\_HISTOGRAM} (histograms). In these cases, the normal
\ccode{\_Create()} interface performs an initial allocation, and the
object keeps track of both its current contents size (often
\ccode{obj->N}) and the current allocation size (often
\ccode{obj->nalloc}). 

In some other cases, objects might be either growable or not,
depending on how they're being used. This happens, for instance, when
we have routines for parsing input data to create a new object, and we
need to dynamically reallocate as we go because the input doesn't tell
us the total size when we start. For instance, with \ccode{ESL\_TREE}
(phylogenetic trees), sometimes we know exactly the size of the tree
we need to create (because we're making a tree ourselves), and
sometimes we need to create a growable object (because we're reading a
tree from a file). In these cases, the normal \ccode{\_Create()}
interface creates a static, nongrowable object of known size, and a
\ccode{\_CreateGrowable()} interface specifies an initial allocation
for a growable object.

Easel usually handles its own reallocation of growable objects. For
instance, many growable objects have an interface called something
like \ccode{\_Add()} or \ccode{\_Push()} for storing the next element
in the object, and this interface will deal with increasing allocation
size as needed.  In a few cases, a public \ccode{\_Grow()} interface
is provided for reallocating an object to a larger size, in cases
where a caller might need to grow the object itself. \ccode{\_Grow()}
only increases an allocation when it is necessary, so that a caller
can call \ccode{\_Grow()} before every attempt to add a new
element. An example of where a public \ccode{\_Grow()} interface is
generally provided is when an object might be input from different
file formats, and an application may need to create its own
parser. Although creating an input parser requires familiarity with
the Easel object's internal data structures, at least the
\ccode{\_Grow()} interface frees the caller from having to understand
its memory management.

Growable objects waste memory, because they are overallocated in order
to reduce the number of calls to \ccode{malloc()}.  The wastage is
bounded (to a maximum of two-fold, for the default doubling
strategies, once an object has exceeded its initial allocation size)
but nonetheless may not always be tolerable.  A \ccode{\_Shrink()}
interface optimizes the memory usage in an object and converts it to a
nongrowable, fixed-size form. 

In summary: 

\begin{sreapi}
\hypertarget{ifc:CreateGrowable}
{\item[\_CreateGrowable(nalloc)]}

A \ccode{\_CreateGrowable()} interface creates a growable
\ccode{obj}. If a size argument like \ccode{nalloc} is provided, it
specifies an initial allocation size, not the number of elements.

\hypertarget{ifc:Grow}
{\item[\_Grow(obj)]}

Check to see if \ccode{obj} can hold another element. If not, increase
the allocation, according to internally stored rules on reallocation
strategy (usually, by doubling).

\hypertarget{ifc:Shrink}
{\item[\_Shrink(obj)]}

Optimize the memory usage in growable object \ccode{obj}, converting
it to a fixed-size, nongrowable object.

\hypertarget{ifc:CreateCustom}
{\item[\_CreateCustom(my\_nalloc)]}

A \ccode{\_CreateCustom()} interface to a growable object might enable
a caller to alter the object's default initial allocation size, for
cases where the \ccode{Create()} interface uses a hardcoded default
size and this default size might not suffice for all applications.

\hypertarget{ifc:SetGrowth}
{\item[\_SetGrowth(obj, nfactor)]}

Growable objects are usually reallocated by increasing the current
allocation by some factor. The default reallocation factor is usually
2, so that objects usually grow by doubling. The API may provide a
\ccode{\_SetGrowth()} interface for changing the reallocation factor
for \ccode{obj} to \ccode{nfactor} at any time.
\end{sreapi}




\subsubsection{Reusable objects}

Memory allocation is computationally expensive. An application needs
to minimize \ccode{malloc()/free()} calls in performance-critical
regions. In loops where one \ccode{\_Destroy()}'s an old object only
to \ccode{\_Create()} the next one, such as a sequential input loop
that processes objects from a file one at a time, one generally wants
to \ccode{\_Reuse()} the same object instead:

\begin{sreapi}
\hypertarget{ifc:Reuse}
{\item[\_Reuse(obj)]}

A \ccode{\_Reuse()} interface takes an existing object and
reinitializes it as a new object, while reusing as much memory as
possible. It replaces a \ccode{\_Destroy()/\_Create()} pair. A
\ccode{\_Reuse()} interface does not care whether the object was
originally created by a \ccode{\_Create()} or a \ccode{\_Inflate()}
call (see below), or whether the object is growable or not (if it was
growable, it remains growable).
\end{sreapi}

For example:

\begin{cchunk}
   ESL_SQFILE *sqfp;
   ESL_SQ     *sq;

   esl_sqfile_Open(\"foo.fa\", eslSQFILE_FASTA, NULL, &sqfp);
   sq = esl_sq_Create();
   while (esl_sqio_Read(sqfp, sq) == eslOK)
    {
       /* do stuff with this sq */
       esl_sq_Reuse(sq);
    }
   esl_sq_Destroy(sq);
\end{cchunk}


\subsubsection{Stack-allocated objects}

Most of Easel's objects are allocated on the heap; that is,
\ccode{malloc()'ed} memory accessed exclusively via pointers. Less
often, an interface may allow the shell of an object to be allocated
on the stack instead, using \ccode{\_Inflate(),\_Deflate()}.  The only
difference between \ccode{\_Inflate(),\_Deflate()} and
\ccode{\_Create(),\_Destroy()} is whether the object shell itself
needs to be allocated, or not:

\begin{sreapi}
\hypertarget{ifc:Inflate}
{\item[\_Inflate()]}

An \ccode{\_Inflate(\&foo)} interface is the on-stack version of
\ccode{foo = \_Create()}. The contents of an existing object shell
are allocated just as in \ccode{\_Create()}.

\hypertarget{ifc:Deflate}
{\item[\_Deflate()]}

A \ccode{\_Deflate(\&foo)} interface is the on-stack version of
\ccode{\_Destroy(foo)}. The contents of an object shell are free'd,
just as in \ccode{\_Destroy()}.
\end{sreapi}

For example:

\begin{cchunk}
   ESL_SQ  sq;

   esl_sq_Inflate(&sq);
   esl_sq_Deflate(&sq);
\end{cchunk}


\subsection{Manipulating and accessing objects}

\begin{sreapi}
\hypertarget{ifc:Copy}
{\item[\_Copy(src, dest)]}

Copies \ccode{src} object into \ccode{dest}, where the caller has
already created an appropriately allocated and empty \ccode{dest}
object. Returns \ccode{ESL\_OK} on success; throws
\ccode{ESL\_EINCOMPAT} if the objects are not compatible (for example,
two matrices that are not the same size).

Note that the order of the arguments is always \ccode{src}
$\rightarrow$ \ccode{dest} (unlike the C library's \ccode{strcpy()}
convention, which is the opposite order).

\hypertarget{ifc:Duplicate}
{\item[\ccode{\_Duplicate(obj)}] }

Creates and returns a pointer to a duplicate of \ccode{obj}.
Equivalent to (and is a shortcut for) \ccode{dest = \_Create();
\_Copy(src, dest)}. Caller is responsible for free'ing the duplicate
object, just as if it had been \ccode{\_Create}'d. Throws NULL if
allocation fails.

\hypertarget{ifc:Set}
\item[\ccode{\_Set*(obj, value...)}]

Initializes some value(s) in \ccode{obj} to
\ccode{value}. \ccode{\_Set} functions have some appropriate longer
name, like \ccode{\_SetZero()} (set something in an object to
zero(s)), or \ccode{esl\_dmatrix\_SetIdentity()} (set a dmatrix to an
identity matrix).

\hypertarget{ifc:Get}
{\item[\ccode{\_Get*(obj, ..., \&ret\_value)}]}

Retrieves some specified data from \ccode{obj}, leave it in
\ccode{ret\_value}.

\hypertarget{ifc:Compare}
{\item[\ccode{\_Compare*(obj1, obj2...)}]}

Compares \ccode{obj1} to \ccode{obj2}. Returns \ccode{eslOK} if the
contents are judged to be identical, and \ccode{eslFAIL} if they
differ. When the comparison involves floating point scalar
comparisons, a fractional tolerance argument \ccode{tol} is also
passed. 

% examples: esl_dmatrix_Compare(), static msa_compare(),
%   esl_tree_Compare(), esl_vec_{DFI}Compare().
\end{sreapi}



\subsection{Debugging, testing, development interfaces}

\begin{sreapi}
\hypertarget{ifc:Dump}
{\item[\ccode{\_Dump*(FILE *fp, obj...)}]}

Prints the internals of an object in human-readable, easily parsable
tabular ASCII form. Useful during debugging and development to view
the entire object at a glance. Returns \ccode{eslOK} on success.

\hypertarget{ifc:Validate}
{\item[\ccode{\_Validate*(obj, errbuf...)}]}

Checks that the internals of \ccode{obj} are all right. Returns
\ccode{eslOK} if they are, and throws \ccode{eslFAIL} if they
aren't. Additionally, if the caller provides a non-\ccode{NULL}
message buffer \ccode{errbuf}, on failure, an informative message
describing the reason for the failure is formatted and left in
\ccode{errbuf}. If the caller provides this message buffer, it must
allocate it for at least \ccode{p7_ERRBUFSIZE} characters.

The intent of a \ccode{_Validate()} call is to detect problems as
normal errors, so they may be handled gracefully or even silently, if
that's what the caller wants to do. (Throwing exceptions instead would
give the caller no flexibility in dealing with failed validations.)
Like an \ccode{assert()} call, a \ccode{\_Validate()} call is mainly
intended for debugging and catching serious coding errors in
development code; whether to include such calls in production code is
a judgement call.

\end{sreapi}



\subsection{Other interfaces}

\begin{sreapi}
\hypertarget{ifc:Describe}
{\item[\ccode{\_DescribeXXX()}]}

Given an internal code (an \ccode{enum} or \ccode{\#define} constant),
return a pointer to an informative string, for diagnostics and other
output. The string is static.
\end{sreapi}


\section{Discipline of writing Easel modules}

In the language below, some words have specific meanings. \emph{Must}
means a true requirement: noncompliance means the code is
broken. \emph{Shall} means a requirement for \emph{new} Easel code,
including revisions to existing modules, though it is understood that
older Easel code is ``grandfathered in'' and may not currently meet
this spec. (The analogy is in how housing construction codes evolve
and improve. New housing codes don't force all old construction to be
immediately renovated to meet the new requirements, but it does force
all new homes and renovations to meet current requirements. Thus, over
time, housing evolves and improves.)  \emph{Should} means a best
practice, the preferred or recommended choice among compliant
alternatives. \emph{May} means a non-preferred or less frequent choice
among compliant alternatives.\footnote{If you're familiar with
RFC2119, it considers ``must'', ``required'', and ``shall'' to be
equivalent. It is designed for static specifications. It does not
define a term suitable for evolving a specification and grandfathering
in older code.}

\subsection{API}

\begin{enumerate}
\item Exposed function names shall obey Easel conventions.

\item All \ccode{ret\_*} pointers for retrieving info from a function
      shall be optional: that is, they may be passed as NULL for
      any returned results the caller doesn't want.
      
\item On any error (returned or thrown), a function must release any
      memory it has allocated, and all \ccode{ret\_*} pointers are set
      to \ccode{NULL} or 0, depending on their type.

\item Any Easel function that calls another Easel function must catch
      any thrown errors. Within the library, we can't assume that the
      error handler is set to be a fatal one.
\end{enumerate}


\subsection{Documentation}

\begin{enumerate}
\item Documentation in .tex files is written to application developers
      (and me); documentation in .c comments is written to Easel
      developers (and me).

\item Every module has a .tex file documenting the module and its API,
      and (if it makes sense) also the particular implementation.

\item Every function exposed to the API can be autodocumented (comment
      header can be converted to \LaTeX) with
      \ccode{autodoc\_functions}, in order to produce appendices
      summarizing the complete Easel function set.
\end{enumerate}


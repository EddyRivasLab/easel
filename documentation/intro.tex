



Easel is a C code library for bioinformatics applications. It
underlies some of the software packages from the Eddy lab, including
HMMER and Infernal, the software engines that the Pfam and Rfam
protein and RNA family databases rely on. Easel organizes a body of my
work in what I hope is a useful form, so that new people in my lab can
avoid reinventing the wheel as many times as I have. Perhaps it will
also be useful to you.

Easel is designed so that it can be used quickly and easily. It is
\textbf{documented} with tutorial examples that are intended to make
it easy to get started with any given Easel module. It is
\textbf{modular}, to help you extract individual files or functions
for use in your own code, without having to disentangle the entire
library. It is \textbf{freely distributed} as open source so that you
can use and modify Easel for anything, including commercial purposes.

\section{Quick start}

Let's assume you just want to take a quick tour, because you're
deciding whether Easel is useful or not. You can compile Easel and try
it out without installing it. 

After you obtain an Easel source tarball (from
\url{http://selab.janelia.org/easel}, for example), it should compile
out of the box on any UNIX, Linux, or Mac OS/X operating
system\footnote{You need a C compilation environment, which you might
not have. If not, install a C compiler first, such as the free GNU gcc
compiler, or see your local system guru.} with this incantation
(where \ccode{xxx} is a version number):

\begin{cchunk}
% tar zxf easel-xxx.tar.gz
% cd easel-xxx
% ./configure
% make
% make check
\end{cchunk}

The \ccode{make check} command is optional. It runs a battery of
quality control tests. All of these should pass. You should now see
\ccode{libeasel.a} in the directory.

Every source code module (that is, each \ccode{.c} file) ends with one
or more \esldef{driver programs}, including programs for unit tests
and benchmarks. These are \ccode{main()} functions that can be
conditionally included when the module is compiled. Among them is
always at least one \esldef{example driver} that shows you how to use
the module. You can find the example code in a module \eslmod{foo} by
searching the \ccode{esl\_foo.c} file for the tag
\ccode{eslFOO\_EXAMPLE}. To compile the example for module
\eslmod{foo} as a working program, do:

\begin{cchunk}
   % cc -o example -L. -I. -DeslFOO_EXAMPLE esl_foo.c -leasel -lm
\end{cchunk}

You might need to replace the standard $\ccode{cc}$ with a different
compiler name, depending on your system. Linking to the standard math
library (\ccode{-lm}) may not be necessary, depending on what module
you're compiling, but it won't hurt. The \ccode{-L.} and \ccode{-I.}
options say that the library and the include files are in the current
working directory (because you haven't installed them). Replace
\ccode{foo} with the name of a module you want to play with, and you
can compile any of Easel's example drivers this way.

To run it, read the source code to see if it needs any command line
arguments, like the name of a file to open, then:

\begin{cchunk}
   % ./example <any args needed>
\end{cchunk}

You can edit the example driver to play around with it, if you like,
but it's better to make a copy of it in your own file (say,
\ccode{foo\_example.c}) so you're not changing Easel's code. When you
extract the code into a file, copy what's between the \ccode{\#ifdef
eslFOO\_EXAMPLE} and \ccode{\#endif /*eslFOO\_EXAMPLE*/} flags that
conditionally include the example driver (don't copy the flags
themselves).  Compile your example code like this:

\begin{cchunk}
   % cc -o foo_example -L. -I. foo_example.c esl_foo.c -leasel -lm
\end{cchunk}

That's it. Now you can compile Easel-based programs that you can
modify and play around with. If you're the type (like me) that learns
best by example, you're on your way. The next section (below) will
introduce the different modules in Easel, so you can see what you
might be interested in. When you want to know more about a module,
either check that module's chapter in this guide, or just read the
module's source code. Most of the documentation is compiled
automatically from the source code comments anyway.

If you decide you want to install Easel permanently, see the full
installation instructions in chapter~\ref{chapter:installation}.

\section{Overview of Easel's modules}

Each \ccode{.c} file in Easel corresponds to one Easel \esldef{module}.
A module consists of a group of functions for some
task. Table~\ref{tbl:module_list} shows a list of all the modules. For
example, the \eslmod{sqio} module can automatically parse many common
unaligned sequence formats, and the \eslmod{msa} module can parse many
common multiple alignment formats.

% documentation/esl-depends.pl
% can autoextract the module dependencies, including augmentations,
% but this table seems to work best as a simple list of modules.
%
\begin{table}
\begin{center}
\begin{tabular}{lll}\hline
\textbf{Module} & \textbf{Description} \\
  \multicolumn{2}{c}{\textbf{Foundation:}}\\
%
\eslmod{easel}           & Framework for using Easel & \\
%
  \multicolumn{2}{c}{\textbf{Core modules:}}\\
%
\eslmod{alphabet}        & Digitized biosequence alphabets        \\
\eslmod{dmatrix}         & Matrix algebra                         \\
\eslmod{fileparser}      & Input of simple token-based data files \\
\eslmod{getopts}         & Command line parsing                   \\
\eslmod{keyhash}         & Keyword hashing                        \\
\eslmod{msa}             & Multiple sequence alignment i/o        \\
\eslmod{random}          & Random number generator                \\
\eslmod{regexp}          & Regular expression matching            \\
\eslmod{sqio}            & Sequence file i/o                      \\
\eslmod{ssi}             & Indices for large sequence files       \\
\eslmod{stack}           & Pushdown stacks                        \\
\eslmod{stats}           & Foundation for statistics group        \\
\eslmod{stopwatch}       & Timing parts of programs               \\
\eslmod{vectorops}       & Vector operations                      \\
%
  \multicolumn{2}{c}{\textbf{Numerical computing group:}}\\
%
\eslmod{minimizer}       & Multidimensional optimization          \\
%
  \multicolumn{2}{c}{\textbf{Statistics group:}}             \\
%
\eslmod{histogram}    & Collecting/fitting data histograms   \\
\eslmod{dirichlet}    & Dirichlet densities.                 \\
\eslmod{exponential}  & Exponential densities.               \\
\eslmod{gamma}        & Gamma densities.                     \\
\eslmod{gev}          & Generalized extreme value (GEV) densities \\
\eslmod{gumbel}       & Gumbel densities.                    \\
\eslmod{hyperexp}     & Hyperexponential densities.          \\
\eslmod{mixdchlet}    & Mixture Dirichlet densities.         \\
\eslmod{mixgev}       & Mixture GEV densities.              \\
\eslmod{stretchexp}   & Stretched exponential densities.    \\
\eslmod{weibull}      & Weibull densities.                  \\
%
  \multicolumn{2}{c}{\textbf{Miscellaneous:}}\\
\eslmod{bioparse\_paml}  & PAML rate matrix datafiles        \\
\eslmod{ratematrix}      & Evolutionary rate matrices        \\
\eslmod{wuss}            & RNA structure annotation          \\
%
  \multicolumn{2}{c}{\textbf{Optional library interfaces:}}\\
%
interface\_gsl    & GNU Scientific Library          \\
interface\_lapack & LAPACK linear algebra library   \\
\hline
\end{tabular}
\end{center}
\caption{Overview of Easel's modules.}
\label{tbl:module_list}
\end{table}

Though you would normally use Easel as a C library
(\ccode{libeasel.a}) that you link with your code, Easel is also
designed to be sufficiently modular that you can grab individual
source files out of the library and use them directly in your own
code. For example, to get Easel's sequence file i/o API, for example,
you can take the sqio module (the C source \ccode{esl\_sqio.c} and the
header \ccode{esl\_sqio.h}), plus the obligatory Easel core
(\ccode{easel.c} and \ccode{easel.h}). Many of Easel's modules are
free-standing, and only depend on the foundation \eslmod{easel}
module. Some modules require a few other modules, but the total number
of modules you have to take to get any particular Easel API is always
small. Each module's documentation shows its required dependencies.

To minimize the number of modules you need to take to get some part of
Easel into your code, Easel uses a concept it calls
\emph{augmentation}. Each module provides a base functionality that is
as simple as possible, and which depends on as few other modules as
possible. When more powerful functionality would require additional
modules, where possible, Easel isolates that functionality and makes
it optional. You can \emph{augment} the module and activate these more
powerful optional abilities by providing the appropriate modules, or
you can leave the optional modules out.  For example, if you use only
the \eslmod{sqio} module, you get the ability to read unaligned
sequence files like FASTA or Genbank; but if you augment \eslmod{sqio}
with the \eslmod{msa} multiple alignment module, you gain the ability
to read individual sequences from multiple alignment files
sequentially. At compile-time, you declare (by means of
\ccode{\#define} flags in \ccode{easel.h}) what modules you've taken,
which defines what augmentations are possible. Each module's
documentation shows what optional augmentations are activated by other
modules. Of course, when Easel is used as a complete
\ccode{libeasel.a} library, all modules are fully augmented.




Many modules are organized around one or a few ``objects'' (usually a
C structure). Table~\ref{tbl:object_list} shows an overview of the
objects you might use (there are a few more objects that are used
internally). This quasi-object-orientation is used to simplify the
code design, focusing each module around a common datatype. 

\begin{table}
\begin{tabular}{lll}\hline
\textbf{Object}          & \textbf{Implemented in} & \textbf{Description}\\\hline
\ccode{ESL\_ALPHABET}    & \cfile{alphabet}        & Digitized sequence alphabet\\
\ccode{ESL\_DMATRIX}     & \cfile{dmatrix}         & 2D double-precision matrix for linear algebra \\
\ccode{ESL\_FILEPARSER}  & \cfile{fileparser}      & Token-based input file parser\\
\ccode{ESL\_GETOPTS}     & \cfile{getopts}         & Application configuration state\\
\ccode{ESL\_HISTOGRAM}   & \cfile{histogram}       & Collecting/fitting data histograms\\
\ccode{ESL\_HYPEREXP}    & \cfile{hyperexp}        & Hyperexponential distribution\\
\ccode{ESL\_KEYHASH}     & \cfile{keyhash}         & Keyword hash table\\
\ccode{ESL\_MIXDCHLET}   & \cfile{dirichlet}       & Mixture Dirichlet prior\\
\ccode{ESL\_MIXGEV}      & \cfile{mixgev}          & Mixture generalized EVD\\
\ccode{ESL\_MSA}         & \cfile{msa}             & Multiple sequence alignment\\
\ccode{ESL\_MSAFILE}     & \cfile{msa}             & Multiple sequence alignment file parser\\
\ccode{ESL\_NEWSSI}      & \cfile{ssi}             & New SSI index being created\\
\ccode{ESL\_OPTIONS}     & \cfile{getopts}         & Configuration of a command-line option\\
\ccode{ESL\_PERMUTATION} & \cfile{dmatrix}         & Permutation matrix used in linear algebra\\
\ccode{ESL\_RANDOMNESS}  & \cfile{random}          & Random number generator\\
\ccode{ESL\_REGEXP}      & \cfile{regexp}          & Regular expression pattern-matching machine\\
\ccode{ESL\_SQ}          & \cfile{sqio}            & DNA/RNA/protein sequence data\\
\ccode{ESL\_SQFILE}      & \cfile{sqio}            & Biosequence file parser (unaligned)\\
\ccode{ESL\_SSI}         & \cfile{ssi}             & An SSI index being used\\
\ccode{ESL\_STACK}       & \cfile{stack}           & Pushdown stack\\
\ccode{ESL\_STOPWATCH}   & \cfile{stopwatch}       & Timer for parts of a program\\
\hline
\end{tabular}
\caption{Overview of Easel's objects.}
\label{tbl:object_list}
\end{table}

A pitfall of putting data into complex, custom datatypes is that this
can impede code reuse. You don't want to understand what's in someone
else's object, and you probably have your own favorite ways of
organizing data.  Easel assumes you are only going to use Easel
objects to call Easel functions, so you will build simple interfaces
to exchange data between your code and Easel. Thus, there are always
obvious ways to create new Easel objects from elemental data types,
and to extract elemental data types from Easel objects. Easel objects
are translucent, if not transparent; often, some of their internal
data fields are stable and documented, and you are encouraged to reach
into an object and access elemental data directly.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
(... BELOW HERE IS STILL JUNK ...)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


A \textbf{test} driver is for unit testing. It provides a
\ccode{main()} that runs some (preferably all) of a module's API. A
test driver takes no command line arguments; it just runs one or more
internal tests. Any failure indicates a bug. Test drivers are intended
for the use by automated tests, or by a developer during debugging.

A \textbf{stats} driver is for collecting some sort of statistics for
the module, such as performance or accuracy. It is only intended for
developer use. Any command line arguments are documented only in the
source code.

A driver is compiled by defining the appropriate flag at compile time:
\ccode{eslMODULE\_EXAMPLE}, \ccode{eslMODULE\_TESTDRIVE}, or
\ccode{eslMODULE\_STATS}, where \ccode{MODULE} is the name of the
module. For example, to compile and run the \eslmod{sqio} example
code:

\begin{cchunk}
   %  gcc -g -Wall -I. -o example -DeslSQIO_EXAMPLE esl_sqio.c easel.c
   %  ./example <FASTA file>
\end{cchunk}

or to compile and run the \eslmod{sqio} test driver:

\begin{cchunk}
   %  gcc -g -Wall -I. -o test -DeslSQIO_TESTDRIVE esl_sqio.c easel.c
   %  ./test
\end{cchunk}

All modules have a test driver and an example driver. Only a few have
stats drivers.



\section{Function naming conventions}

\subsection{Object creation, initialization, destruction}

Most of Easel's objects are allocated on the heap; that is, accessed
exclusively via pointers. Less often, routines may allow an object to
be allocated on the stack.

\begin{sreitems}{\ccode{Create,Destroy}}
\item [\ccode{Create,Destroy}] 
  \ccode{esl\_foo\_Create()} allocates and initializes a new \ccode{ESL\_FOO}
  object, returning a pointer to the new
  object. The \ccode{Create()} function is passed any necessary
  initialization or size information in its arguments.
  \ccode{esl\_foo\_Destroy(obj)} frees all the memory associated
  with a \ccode{ESL\_FOO} object,  given a pointer to the object,
  and returns \ccode{ESL\_OK}. Example:

\begin{cchunk}
ESL_SQ *sq;

sq = esl_sq_Create();
esl_sq_Destroy(sq);
\end{cchunk}
  
\item [\ccode{Open,Close}] 
  Same as \ccode{Create()} and \ccode{Destroy()}, but specifically for
  objects associated with input/output streams. Example:

\begin{cchunk}
char        *seqfile = ``foo.seq'';
ESL_SIO     *sqfp;

sqfp = esl_sio_Open(seqfile);
esl_sio_Close(sqfp);
\end{cchunk}


\item [\ccode{Inflate,Deflate}]
  \ccode{esl\_foo\_Inflate(\&obj)} takes a pointer to the ``shell'' of an
  \ccode{ESL\_FOO} object that has been allocated on the stack, and
  allocates and initializes all the internals of it. The
  \ccode{Inflate()} function is passed any necessary initialization or
  size information in its arguments.  \ccode{esl\_foo\_Deflate(\&obj)}
  frees all the internal memory associated with a \ccode{ESL\_FOO} object,
  given a pointer to the object, but the object shell is left alone.
  The only difference between \ccode{Create,Destroy} and
  \ccode{Inflate,Deflate} is whether the object shell itself is to be
  allocated, or not. Example:

\begin{cchunk}
ESL_SQ  sq;

esl_sq_Inflate(&sq);
esl_sq_Deflate(&sq);
\end{cchunk}



\item [\ccode{Expand,Squeeze}]
   These deal with objects whose contents are not necessarily of a
   fixed size, but can grow and require reallocation of internal data
   fields. A function \ccode{esl\_foo\_Expand()} reallocates an
   \ccode{ESL\_FOO} object to a larger size. Usually, reallocation
   works by doubling the previous allocation. The redoubling strategy
   can result in a fair amount of unused memory overhead (up to
   50\%). A function \ccode{esl\_foo\_Squeeze()} takes a fully-grown
   object and optimizes its memory usage, recovering this wastage
   overhead, on the assumption that no more reallocation will be
   done.



\item [\ccode{Reuse}] 
   \ccode{esl\_foo\_Reuse(obj)} reinitializes an object exactly as a
   \ccode{Create} or \ccode{Inflate} function would initialize it, \emph{without}
   allocating new memory; it reuses memory that has
   already been allocated when the object was originally created or
   inflated. For some objects that are used sequentially (like,
   sequences), reusing one object saves malloc()'s compared to
   lots of Create/Destroy calls. A \ccode{Reuse} function does not
   care whether the object was originally created by a \ccode{Create}
   or a \ccode{Inflate} call. Example:

\begin{cchunk}
ESL_SQ *sq;

sq = esl_sq_Create();
  /* read a sequence into the sq object, have fun with it */

esl_sq_Reuse(sq);
  /* read a second sequence into it */

esl_sq_Destroy(sq);
\end{cchunk}

\end{sreitems}

\subsection{Other common object manipulation functions}

\begin{sreitems}{\ccode{\_Copy(src, dest)}}

\item[\ccode{\_Copy(src, dest)}]
Copies \ccode{src} object into \ccode{dest}, where the caller has
already created the empty \ccode{dest} object. Returns \ccode{ESL\_OK}
on success; throws \ccode{ESL\_EINCOMPAT} if the objects are not
compatible (for example, two matrices that are not the same size).

The order of the arguments is always \ccode{src} $\rightarrow$
\ccode{dest} (unlike the C library's \ccode{strcpy()} convention, which
is the opposite order).

\item[\ccode{\_Duplicate(obj)}] 

Creates and returns a pointer to a duplicate of \ccode{obj}.
Equivalent to (and is a shortcut for) \ccode{dest = \_Create();
\_Copy(src, dest)}. Caller is responsible for free'ing the duplicate
object, just as if it had been \ccode{\_Create}'d. Throws NULL if
allocation fails.

\item[\ccode{\_Set*(obj, value...)}]

Initializes value(s) in \ccode{obj} to \ccode{value}. Special cases of
\ccode{\_Set*} functions may exist, like \ccode{\_SetZero} (set to
zero(s)), or \ccode{esl\_dmatrix\_SetIdentity} (set a dmatrix to an
identity matrix).

\end{sreitems}




\section{Discipline of writing Easel modules}


\subsection{API}

\begin{enumerate}
\item Exposed function names obey Easel conventions.

\item All \ccode{ret\_*} pointers for retrieving info from 
      a function are implemented as optional.

\item On any error (returned or thrown), a function releases any
      memory it has allocated, and all \ccode{ret\_*} pointers are
      \ccode{NULL} or 0, depending on their type.

\item Any function that calls another Easel function must 
      catch any thrown errors. Within Easel, we
      can't assume that the error handler is set to be a fatal
      one.
\end{enumerate}


\subsection{Documentation}

\begin{enumerate}
\item Documentation in .tex files is written to application developers
      (and me); documentation in .c comments is written to Easel
      developers (and me).

\item Every module has a .tex file documenting the module and its API,
      and (if it makes sense) also the particular implementation.

\item Every function exposed to the API can be autodocumented (comment
      header can be converted to \LaTeX) with
      \ccode{autodoc\_functions}, in order to produce appendices
      summarizing the complete Easel function set.
\end{enumerate}


\subsection{Testing}

\begin{enumerate}

\item Every module has a test driver which exercises the API in some
      simple way (and, in the process, provides a ``hello world''
      level example of using the module).

\end{enumerate}











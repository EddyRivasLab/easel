The random (rnd) module contains routines for generating pseudorandom
numbers.

The standard ANSI C library provides a random number generator in
\ccode{rand()}. However, the implementation of \ccode{rand()} varies
from platform to platform, thwarting reproducibility of results that
depend on being able to reproduce the same pseudorandom number series.
Moreover, on many platforms \ccode{rand()} is only a weak pseudorandom
number generator.  It is desirable to have a standard, portable,
strong pseudorandom number generator that generates reproducible
pseudorandom number series on any platform.  Thus Easel's
\ccode{esl\_random()} function, which returns a double-precision
uniform deviate $x$ on the interval $0 \leq x < 1$.

The algorithm implemented by \ccode{esl\_random()} is strong, but a
bit slow compared to some other strong random number generators. It is
essentially the \ccode{ran2()} generator from \emph{Numerical Recipes
in C} \cite{Press92}. It implements L'Ecuyer's algorithm for combining
two linear congruential generators, with a Bays-Durham shuffle.

The state of the random generator is encapsulated in an
\ccode{ESL\_RANDOMNESS} object. This makes random number generation
reentrant and threadsafe. We can have more than one active generator,
and they will not interfere with each other. Many standard generators
use static variables and are not reentrant or threadsafe.

When a \ccode{ESL\_RANDOMNESS} object is created with
\ccode{esl\_randomness\_Create()}, it needs to be given a \emph{seed},
an integer $> 0$, which specifies the initial state of the
generator. After a generator is seeded, it is typically never seeded
again. A series of \ccode{esl\_random()} calls generates a
pseudorandom number sequence from that starting point. If you create
two \ccode{ESL\_RANDOMNESS} objects seeded identically, they are
guaranteed to generate the same random number sequence on all
platforms. This makes it possible to reproduce stochastic simulations.

Often one wants different runs to generate different random number
sequences, which creates a chicken and the egg problem: how can we
select a pseudorandom seed for the pseudorandom number generator? A
standard method is to use the current time. Easel provides an
alternate creation function
\ccode{esl\_randomness\_CreateTimeseeded()} that uses this method. If
the precision of our clock is sufficiently fine, different runs of the
program occur at different clock times. Easel relies on the POSIX
clock for portability, but the POSIX clock has the drawback that it
clicks in seconds, which is not very good precision. Two
\ccode{ESL\_RANDOMNESS} objects created in different seconds will
produce different random number sequences, but two different
\ccode{ESL\_RANDOMNESS} objects created in the same second
(accidentally or not) will generate identical random number sequences.

The other elementary sampling functions provided by the random module
all rely on \ccode{esl\_random()} to generate the random numbers they
use.


\subsection{Example}

\begin{cchunk}
#include <stdio.h>

#include <easel/easel.h>
#include <easel/random.h>

int 
main(void)
{
  ESL_RANDOMNESS *r;
  double          x;
  int             n;
  
  r = esl_randomness_Create(42); 
  n = 10;

  printf("A sequence of %d pseudorandom numbers:\n", n);
  while (n--) {
    x = esl_random(r);
    printf("%f\n", x);
  }

  esl_randomness_Destroy(r);
  return 0;
}
\end{cchunk}

To compile and run this:
\begin{cchunk}
  % cc -g -Wall -I. -o random_test -DESL_RANDOM_TESTDRIVE random.c easel.c -lm
  % ./random_test
\end{cchunk}

If you run it multiple times, you get the same ten numbers, because
the generator is always seeded with the same number (42). Change the
\ccode{esl\_randomness\_Create(42)} call to
\ccode{esl\_randomness\_CreateTimeseeded()} and recompile, and you'll
get different sequences with each run - provided you run the commands
in different seconds, anyway.






The easel (esl) module implements a small set of functionality shared
by all the modules: notably, the error-handling system.

\subsection{Error handling}

Easel is intended for use in applications ranging from quick \& dirty
one-off command line applications to complex graphical user interfaces
and parallel systems. Simple and complex applications have different
views of how errors and exceptions should be handled by a library.  On
the one hand, a robust application wants a guarantee that execution
never terminates within a library routine; control should be returned
to the application even in the most dire and unexpected
circumstances. We don't want Easel to crash a whole graphical user
environment, for example. And because an application is not
necessarily associated with a terminal, Easel cannot print error
messages directly to \emph{stderr}; \emph{stderr} may not go anywhere
useful. On the other hand, a quick \& dirty command line application
doesn't want to use lots of code checking for various dire and
unexpected errors. It would prefer to have Easel crash out with an
appropriate message to \ccode{stderr} -- that's all a simple
application would do anyway.

Easel processes all \textbf{exceptions} with one function,
\eslfunc{esl\_error()}, which takes an error code, error message,
source file name, and source line number as arguments.
\eslfunc{esl\_error()}, hands this information to a customizable error
handling function. The default error handler is a fatal one, which
performs the simple behavior: it prints the error message to
\ccode{stderr} and aborts execution. Therefore, by default,
applications can rely on Easel to handle its own exceptions.  In an
application that wants to handle all exceptions itself, and wants a
guarantee that execution will never terminate from within Easel, a
custom nonfatal error handler can be assigned to \eslfunc{esl\_error()},
one which merely catches the information from Easel (and reacts
appropriately) but returns control to Easel at the point of
failure. Easel percolates the error code up through its call stack
until control returns to your application with an appropriate nonzero
error code. \footnote{The idioms used in Easel to handle serious
exceptions non-fatally look a lot like exception handling in more
modern languages like C++/Java.}

Easel distinguishes exceptions from \textbf{normal errors}. ``Normal''
errors are conditions that any application should handle gracefully,
even a simple application. One example is an end-of-file indicator
from an input routine. Most importantly, any problem that is the fault
of the user (typo in a command line argument, bad file format, and
suchlike) is called a normal error. (Bad user input is ``normal''. It
should not crash a program with an exception.) Easel functions handle
normal errors by directly returning an appropriate nonzero status code
to the caller, without sending a message through the handler in
\eslfunc{esl\_error()}. A limitation of this approach is that your
application only gets a status code, not a message, when a normal
error occurs. Often the status code is sufficient for your application
to know what happened. For instance, \ccode{eslEOF} means end-of-file,
so your application might report \ccode{"premature end of file"} if it
receives such a status code unexpectedly. But when the error involves
a file format syntax problem (for instance) a terse \ccode{eslESYNTAX}
return code is not as useful as knowing \ccode{\"Parse failed at line
42 of file foo.data: expected integer, got 'boo!'\"}. File parsers in
Easel are generally encapsulated in objects; these objects include a
\ccode{errbuf[]} string that contains a useful error message when a
parser function returns a normal error. (For instance, see the
\eslmod{sqio} module and its \ccode{ESL\_SQFILE} object for sequence
file parsing.)

Easel also distinguishes a third class of error, termed
\textbf{violations}. Violations are bugs: problems that should never
arise in production code, and that should be caught during development
and testing. Violations result in an \ccode{abort()} and immediate
program termination; therefore, they never occur in production
code. They are generated by two mechanisms: from assertions that can
be optionally enabled in development code, or from test harnesses that
call the always-fatal \eslfunc{esl\_fatal()} function when they detect a
problem they're testing for. For example, Easel uses conditionally
compiled assertions to test for violations of Easel's API design
contracts. \footnote{``Design-by-contract'' is a useful software
engineering concept introduced by the Eiffel language
[\url{www.eiffel.com}]. C does not inherently support DBC, but Easel
partially emulates it using assertions.}

\subsubsection{Error handling: application perspective}

Almost all Easel functions return an integer status code, where
\ccode{eslOK} (0) indicates success and a nonzero code indicates a
failure. The list of status codes is shown in
Table~\ref{tbl:statuscodes}.

\begin{table}
\begin{center}
\input{cexcerpts/statuscodes}
\end{center}
\caption{List of all status codes that might be returned by Easel functions.}
\label{tbl:statuscodes}
\end{table}

There are some exceptions. Some \ccode{*\_Create()} functions that
allocate and create new objects follow a convention of returning a
valid pointer on success, and \ccode{NULL} on failure; these are
functions that only fail by memory allocation failure. Destructor
functions (\ccode{*\_Destroy()}) always return \ccode{void}, and must
have no points of failure of their own, because destructors can be
called when we're already handling an exception. Finally, there are
some functions that simply return an answer, rather than a status
code; these must be functions that have no failure points. Easel is
not completely dogmatic.

Documentation of individual Easel functions refers to exceptions that
are handled by \eslfunc{esl\_error()} as \textbf{thrown}, and normal
error conditions that directly return an error status code as
\textbf{returned}.  From the perspective of an application developer
using Easel, any \emph{returned} error codes \textbf{must} always be
checked. Moreover, a function's documentation always lists all
possible return codes that you need to deal with.  In contrast, a
simple application does not need to pay attention to thrown exceptions
at all. The default error handler deals with them (fatally). However,
an application that registers a custom nonfatal error handler does
need to check for both returned errors and thrown exceptions. Although
each function's documentation \emph{in principle} lists all thrown
exceptions, \emph{in practice}, an application developer should not
trust this list. Because exceptions may percolate up from other Easel
calls, it is easy to forget to document all possible
exceptions.\footnote{If we combined a static code analyzer with a
script that understands Easel's exception conventions, we could
automate the enumeration of all possible codes. This would be a Good
Thing to do in the future.} An application that's catching exceptions
should always have a failsafe catch for any nonzero return status. For
example, a minimal try/catch idiom for an application calling a Easel
function is something like:

\begin{cchunk}
     int status;
     if ((status = esl_foo_function()) != eslOK)  my_failure_function();
\end{cchunk}

A little more complex one that catches some specific errors, but has a
failsafe for everything else, is:

\begin{cchunk}
     int status;
     status = esl_foo_function();
     if      (status == eslEMEM) my_failure("Memory allocation failure");
     else if (status != eslOK)   my_failure("Unexpected exception %d\n\", status);
\end{cchunk}

Finally, the exception-catching idiom used in Easel's own source is
one way of consistently cleaning up and guaranteeing a certain state
upon failure, before percolating an exception code upwards:

\begin{cchunk}
     int status;
     if ((status = esl_foo_function()) != eslOK)  goto FAILURE;
     ... do other stuff...
     return eslOK;

  FAILURE:
     free(whatever);
     set(any return variables);
     return status;
\end{cchunk}


\subsubsection{Replacing the default error handler}

\eslfunc{esl\_error()} gets as arguments a status code, file and
linenumber for where the error occurred, and a \cfunc{printf()}-style
message. By default, it prints the message and exits:

\begin{cchunk}
Easel fatal error:
Memory allocation failed.

Aborted at file sqio.c, line 42. 
\end{cchunk}

An application can define its own handler for the same information,
and override this default behavior. To do this, you define the error
handler with the following prototype:

\begin{cchunk}
extern void my_error_handler(int code, char *file, int line, char *format, va_list arg);
\end{cchunk}

An example implementation of an error handler:

\begin{cchunk}
#include <stdarg.h>

void
my_error_handler(int code, char *file, int line, char *format, va_list arg)
{
  fprintf(stderr, ``Easel threw an error (code %d):\n'', code);
  vfprintf(stderr, format, arg);
  fprintf(stderr, ``at line %d, file %s\b'', line, file);
  return;
}
\end{cchunk}

To configure Easel to use your error handler, call
\eslfunc{esl\_error\_SetHandler(\&my\_error\_handler)}. Normally you
would do this before calling any other Easel functions.

However, in principle, you can change error handlers at any time --
including restoring the default handler with
\eslfunc{esl\_error\_RestoreDefaultHandler()}.  The implementation of
the handler relies on a static function pointer that is not
threadsafe, so if you are writing a threaded program, you want to make
sure that multiple threads do not try to change the handler at the
same time.

Because Easel functions may call other Easel functions, the function
that first detects an error may not be the function that your
application called.  If you implement a nonfatal handler, an abnormal
error in Easel may generate a partial stack trace of
\eslfunc{esl\_error()} messages, as the exception percolates up from
the function that detected the error, until control finally returns to
your application. Your error handler should deal with the possibility
of this stack trace. The first \eslfunc{esl\_error()} message is most
relevant, and subsequent messages arise from that error percolating up
through the stack trace.  For example, a sophisticated replacement
\eslfunc{esl\_error()} handler might push each \eslfunc{esl\_error()}
message into a FIFO queue, where they will be waiting for a main
application-specific error handler to access when your application
gets its thrown exception code back from Easel.

\subsubsection{Internal API for exception handling}

You only need to understand this section if you want to understand
Easel's source code (or other code that uses Easel conventions, like
HMMER), or if you want to use Easel's error conventions in your own
source code.

Throwing an exception involves two or three steps. The first is a call
to \eslfunc{esl\_error()} with a status code, \ccode{\_\_FILE\_\_} and
\ccode{\_\_LINE\_\_} information, and an error message. The second (if
necessary) is to clean up and set the failure state (which may include
free'ing allocated memory, restoring an object to its original state,
and setting any returned variables to the values they should have on
failure). The third is to return the error code.

Two wrapper macros implement this convention for almost all
exceptions: \eslfunc{ESL\_ERROR()} and \eslfunc{ESL\_FAIL()}. They are
defined in \ccode{easel.h} as:

\begin{cchunk}
\input{cexcerpts/error_macros}
\end{cchunk}

\eslfunc{ESL\_ERROR()} is the simpler version for when cleanup isn't
necessary. It just calls \eslfunc{esl\_error()} and returns the status
code. \eslfunc{ESL\_FAIL()} implements the three-step version when a
cleanup is needed before the return. It is an offensive little
abomination, because it's not self-contained. It requires an
\ccode{int status} variable in scope, a \ccode{FAILURE:} target for
the \ccode{goto} - and it uses a \ccode{goto}. But if you can stomach
that, it provides for a fairly clean idiom for catching exceptions and
cleaning up, and cleanly setting different return variable states on
success versus failure, as illustrated by this pseudoexample:

\begin{cchunk}
int 
foo(char **ret_buf, char **ret_fp)
{
    int status;
    char *buf = NULL;
    FILE *fp  = NULL;

    if ((buf = malloc(100))  == NULL) ESL_FAIL(eslEMEM,      "malloc failed");
    if ((fp  = fopen("foo")) == NULL) ESL_FAIL(eslENOTFOUND, "file open failed");

    *ret_buf = buf;
    *ret_fp  = fp;
    return eslOK;

  FAILURE:
    if (buf != NULL) free(buf);  *ret_buf = NULL;
    if (fp  != NULL) fclose(fp); *ret_fp  = NULL;
    return status;
}
\end{cchunk}

After a lot of putzing about with different conventions, I think that
might be about as clean as you can make exception handling in C. An
alternative is to actually implement \ccode{try} and \ccode{catch},
using \ccode{setjmp()}/\ccode{longjmp()}, but I don't find such code
to be very pretty.

For memory allocation and reallocation, Easel also uses two macros
\eslfunc{ESL\_ALLOC()} and \eslfunc{ESL\_RALLOC()}, which encapsulate
standard \eslfunc{malloc()} and \eslfunc{realloc()} calls in Easel's
error-throwing convention.



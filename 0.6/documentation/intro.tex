

\begin{quote}
 \emph{...using another person's software is sometimes treated like 
 using their toothbrush.}\\
\hspace*{1em}\hfill - Webb Miller \citep{Miller01}
\end{quote}


Easel is the C library that underlies bioinformatics software packages
from the Eddy lab, including HMMER and Infernal, the
software engines for the Pfam protein family database and the
Rfam RNA family database.

Easel results from years of accretion and gradual refactoring of a
personal codebase for solving common problems encountered in writing
bioinformatics applications, particularly in the area of sequence
analysis.

Easel is not intended to be an all-purpose solution nor a \emph{de
facto} standard. Several general-purpose bioinformatics libraries are
available that do aspire to such goals. The NCBI Toolkit and the Ajax
library in EMBOSS are particularly comprehensive resources for C
programming, and the BioPerl project is an admirably successful
resource for Perl.

Rather, Easel is intended to maintain a body of work from my lab in a
useful form that new people in the lab can adopt quickly, and that
other software developers outside the lab might also benefit from. Its
design follows from a golden rule, \emph{do unto other developers as
you would have them do unto you}:

\begin{description}
\item[\textbf{Documentation.}]  Effort has been invested in practical
documentation, including this Guide, tutorial examples to Easel APIs,
and source-level comments. All too often I've tried to obtain a
routine and ended up unable to understand how to use it because of
missing, incomplete, or obsolete documentation.

\item[\textbf{Modularity.}]  Easel is designed to minimize
dependencies between its routines, to help you take individual files
(or individual routines) for your use, without having to include the
entire library. All too often I've tried to obtain a routine and found it
deeply entangled in a large third-party library. I can either package
the whole library in my software distribution (cumbersome, and a
potential maintainability headache in the long run), or I try to
understand the code well enough to disentangle it. It usually seems
easier to just rewrite it from scratch.

\item[\textbf{No license encumbrance.}]  Easel is freely available
under a Creative Commons Attribution License. You can use it for
anything you want, even commercial products, so long as you keep my
copyright and license notice on the code. All too often I've tried to
reuse a routine and been blocked by someone's license terms. Even some
open source licenses, such as the GNU General Public License (GPL),
can impede right-minded developers who happen to use incompatible
open-source licenses. The CC license just provides me some minimal
legal ablative armor in case you like to sue people that give you
stuff for free.
\end{description}

\section{Overview of modules}

Certain problems recur frequently in sequence analysis software. Each
\ccode{.c} file in Easel contains one \emph{module} that deals with
one such problem.

Parsing the variety of different sequence file formats, for instance,
is a pain. The \eslmod{sqio} module (which shares some remote lines of
descent from Don Gilbert's classic ReadSeq package) can automatically
parse many common unaligned sequence formats, and the \eslmod{msa}
module can parse many common multiple alignment formats.

\begin{tabular}{llll}\hline
\textbf{Module} & \textbf{Description}       & \textbf{Requires} & \textbf{Augmentation(s)}\\\hline
  \multicolumn{4}{c}{\textbf{Core module}}\\
easel           & Framework for using Easel         &  -     & \\
  \multicolumn{4}{c}{\textbf{Foundation modules}}\\
alphabet        & Digitized biosequence alphabets   & easel  & \\
dmatrix         & Matrix algebra                    & easel  & \\ 
fileparser      & Token-based data file input       & easel  & \\
getopts         & Command line parsing              & easel  & \\
keyhash         & Keyword hashing                   & easel  & \\
msa             & Multiple sequence alignment i/o   & easel  & keyhash \\
random          & Random number generator           & easel  & \\
regexp          & Regular expression matching       & easel  & \\
sqio            & Sequence file i/o                 & easel  & alphabet, msa\\
stack           & Pushdown stacks                   & easel  & \\
vectorops       & Vector operations                 & easel  & \\\hline
  \multicolumn{4}{c}{\textbf{Derived modules}}\\
bioparse\_paml  & PAML rate matrix datafiles        & easel dmatrix parse & \\
dirichlet       & Dirichlet densities               & easel vectorops  & fileparser, random \\ 
minimizer       & Multidimensional optimization     & easel vectorops  & \\
ratematrix      & Evolutionary rate matrices        & easel dmatrix vectorops & \\
wuss            & RNA structure annotation          & easel stack    & \\\hline
  \multicolumn{4}{c}{\textbf{Optional library interfaces}}\\
interface\_gsl    & GNU Scientific Library          & easel dmatrix & \\
interface\_lapack & LAPACK linear algebra library   & easel dmatrix & \\\hline
\end{tabular}



\section{Overview of data structures}

\begin{tabular}{lll}\hline
\textbf{Object}          & \textbf{Implemented in} & \textbf{Description}\\\hline
\ccode{ESL\_ALPHABET}    & \cfile{alphabet}        & Digitized sequence alphabet\\
\ccode{ESL\_DMATRIX}     & \cfile{dmatrix}         & 2D double-precision matrix for linear algebra \\
\ccode{ESL\_FILEPARSER}  & \cfile{fileparser}      & Token-based input file parser\\
\ccode{ESL\_GETOPTS}     & \cfile{getopts}         & Application configuration state\\
\ccode{ESL\_KEYHASH}     & \cfile{keyhash}         & Keyword hash table\\
\ccode{ESL\_MIXDCHLET}   & \cfile{dirichlet}       & Mixture Dirichlet prior\\
\ccode{ESL\_MSA}         & \cfile{msa}             & Multiple sequence alignment\\
\ccode{ESL\_MSAFILE}     & \cfile{msa}             & Multiple sequence alignment file parser\\
\ccode{ESL\_PERMUTATION} & \cfile{dmatrix}         & Permutation matrix used in linear algebra\\
\ccode{ESL\_RANDOMNESS}  & \cfile{random}          & Random number generator\\
\ccode{ESL\_REGEXP}      & \cfile{regexp}          & Regular expression pattern-matching machine\\
\ccode{ESL\_SEQFILE}     & \cfile{sqio}            & Biosequence file parser (unaligned)\\
\ccode{ESL\_SQ}          & \cfile{sqio}            & DNA/RNA/protein sequence data\\
\ccode{ESL\_STACK}       & \cfile{stack}           & Pushdown stack\\\hline
\end{tabular}

\section{Using Easel as a library, or as individual modules}

Easel is designed to be used in two different ways: as a C library
(\ccode{libeasel.a}) in the usual C way, or by grabbing individual
source files without the rest of the library.

The ability to borrow individual files from Easel makes it different
from many other C libraries. For example, to get Easel's sequence file
i/o API, for example, you just take the sqio module (the C source
\ccode{esl\_sqio.c} and the header \ccode{esl\_sqio.h}), plus the
obligatory Easel core (\ccode{easel.c} and \ccode{easel.h}). Most of
Easel's modules can stand alone in this way (the \emph{base}
modules). Only a few are dependent on other modules (the
\emph{derived} modules), though even these can be used just by
bringing along the modules they depend on.

There are a couple of reasons to provide standalone capability. One
reason came from teaching a computational molecular biology
course. For homework programming assignments, I wanted to provide
students with simple .c files with well-documented APIs for routine
things like sequence i/o. This was to give them a head start, save
them from implementing boring things, and let them concentrate on
learning algorithms. But at the same time, I wanted them to be able to
see where the functionality was coming from, and to study the .c files
if they wanted, rather than treating the library as a black box -- so
I wanted to give them a few .c files at a time, not a library.

A second reason comes from my frustration with C libraries and code
reuse in bioinformatics in general. If I want to take a single routine
from someone's library (say, gods help us, the NCBI Toolkit), it's
common that that routine has dependencies, and the dependencies have
dependencies, and pretty soon I'm dragging the whole damned library in
just to have access to the routine I wanted. I don't mind that in
standard, widely installed system libraries, but if I'm making a
robustly distributable bioinformatics application, I need to include
in my package all my nonstandard dependencies -- and I really don't
want to have to distribute the entire GNU Scientific Library just to
pick up two GSL functions, all of LAPACK to get one numerical routine,
and the whole NCBI Toolkit to pick up one Toolkit routine.

Thus, Easel is very strictly modular in design. You never need the
entire Easel library to use any one aspect of Easel's
functionality. Most often, you need only the module you're interested
in, plus the core easel module.

To facilitate code reuse, Easel is licensed under a permissive open
source license (the Creative Commons Attribution License) that allows
you to freely modify and redistribute the code.

In the end, some of my original intent of providing simple
implementations as teaching examples has been lost. Rather than
providing two implementations (my intended simple teaching example and
a full-strength production example), Easel code is all production
code. But the modularity remains, and it seems to be useful in other
respects.  Modular design is just a Good Thing in general.  Easel
modules can be unit-tested in absence of the rest of the library.
And, though this remains to be seen, it should be easy for other
people to contribute modules and extend Easel, and it should be easy
for people to borrow and reuse Easel code.

\section{Easel's concept of module ``augmentation''}

The trouble with enforcing strict modular design is that while
\emph{you} (the application writer) can take advantage of any or all
of Easel's functionality as you wish, \emph{Easel} can't. An Easel
module, by design, is as isolated as possible from all other Easel
modules. It shouldn't use any functionality other than the essentials
in the core \eslmod{easel} module. But what if module X would benefit
from the cool features of module Y -- for instance, what if we want
the \eslmod{sqio} sequence i/o module to have access to the fast file
indexing capabilities of the \eslmod{ssi} module?  Start down this
road, and pretty soon the library is full of dependencies, the modular
design collapses, and we're back to a standard all-or-none C library.

Easel introduces a concept called \emph{augmentation}. The base
functionality of many Easel modules can be optionally \emph{augmented}
by one or more other Easel modules. An augmentation confers optional
powers on a module beyond its default standalone behavior.

Sometimes, an augmentation adds new functions to a module's API.  For
example, \eslmod{alphabet} augmentation of the sequence i/o module
\eslmod{sqio} adds a function to the \eslmod{sqio} API for digitizing
a sequence.

Sometimes, an augmentation extends or generalizes the scope of one or
more functions in the API. For instance, augmenting the \eslmod{sqio}
module with \eslmod{msa} gives the ability to read alignment files as
if they were sequential, unaligned sequence databases through
\eslmod{sqio}'s existing API.

And sometimes, an augmentation invisibly makes existing functions
faster or more memory-efficient, without adding any new functionality
per se.  For example, \eslmod{msa} can be augmented by
\eslmod{keyhash}, which makes the \eslmod{msa} module capable of
handling much larger alignments more efficiently than it does by
default, because \eslmod{keyhash} gives it the ability to use fast
hashing methods in its parsers.

When Easel is installed as a library, all modules are fully
augmented. This is done when the library is compiled. The
\ccode{configure} script automatically enables all augmentations when
it sets up the \ccode{easel.h} header, before compiling and installing
the library.

When you borrow an individual module from Easel, you choose whether to
borrow any modules that augment it. To activate an augmentation, you
not only have to compile and link the C code for the extra module
(obviously), you also edit a line in the \ccode{easel.h} header file
before compilation. There is a section at the top of \ccode{easel.h}
that declares which augmentations are to be enabled. You
\ccode{\#define} the appropriate flag for your augmentation to
activate it; for instance, to augment with \eslmod{ssi}, you make sure
\ccode{easel.h} has a line \ccode{\#define eslAUGMENT\_SSI} in place
of \ccode{\#undef eslAUGMENT\_SSI}.

Documentation for modules and their functions always distinguishes
between default functionality and augmented functionality.


\section{Test drivers and example code}

At the end of each source code module is one or more \emph{drivers}
that allow the module to be compiled and tested as independently as
possible, with minimum dependencies on the rest of Easel.

An \textbf{example} driver provides a \ccode{main()} that shows how to
use the module. Example drivers are extracted verbatim from the source
code for inclusion in the module chapters in this guide. Any command
line arguments are documented both in the source code and in this
guide. Example drivers are intended for anyone to use.

A \textbf{test} driver is for unit testing. It provides a
\ccode{main()} that runs some (preferably all) of a module's API. A
test driver takes no command line arguments; it just runs one or more
internal tests. Any failure indicates a bug. Test drivers are intended
for the use by automated tests, or by a developer during debugging.

A \textbf{stats} driver is for collecting some sort of statistics for
the module, such as performance or accuracy. It is only intended for
developer use. Any command line arguments are documented only in the
source code.

A driver is compiled by defining the appropriate flag at compile time:
\ccode{eslMODULE\_EXAMPLE}, \ccode{eslMODULE\_TESTDRIVE}, or
\ccode{eslMODULE\_STATS}, where \ccode{MODULE} is the name of the
module. For example, to compile and run the \eslmod{sqio} example
code:

\begin{cchunk}
   %  gcc -g -Wall -I. -o example -DeslSQIO_EXAMPLE esl_sqio.c easel.c
   %  ./example <FASTA file>
\end{cchunk}

or to compile and run the \eslmod{sqio} test driver:

\begin{cchunk}
   %  gcc -g -Wall -I. -o test -DeslSQIO_TESTDRIVE esl_sqio.c easel.c
   %  ./test
\end{cchunk}

All modules have a test driver and an example driver. Only a few have
stats drivers.



\section{Function naming conventions}

\subsection{Object creation, initialization, destruction}

Most of Easel's objects are allocated on the heap; that is, accessed
exclusively via pointers. Less often, routines may allow an object to
be allocated on the stack.

\begin{sreitems}{\ccode{Create,Destroy}}
\item [\ccode{Create,Destroy}] 
  \ccode{esl\_foo\_Create()} allocates and initializes a new \ccode{ESL\_FOO}
  object, returning a pointer to the new
  object. The \ccode{Create()} function is passed any necessary
  initialization or size information in its arguments.
  \ccode{esl\_foo\_Destroy(obj)} frees all the memory associated
  with a \ccode{ESL\_FOO} object,  given a pointer to the object,
  and returns \ccode{ESL\_OK}. Example:

\begin{cchunk}
ESL_SQ *sq;

sq = esl_sq_Create();
esl_sq_Destroy(sq);
\end{cchunk}
  
\item [\ccode{Open,Close}] 
  Same as \ccode{Create()} and \ccode{Destroy()}, but specifically for
  objects associated with input/output streams. Example:

\begin{cchunk}
char        *seqfile = ``foo.seq'';
ESL_SIO     *sqfp;

sqfp = esl_sio_Open(seqfile);
esl_sio_Close(sqfp);
\end{cchunk}


\item [\ccode{Inflate,Deflate}]
  \ccode{esl\_foo\_Inflate(\&obj)} takes a pointer to the ``shell'' of an
  \ccode{ESL\_FOO} object that has been allocated on the stack, and
  allocates and initializes all the internals of it. The
  \ccode{Inflate()} function is passed any necessary initialization or
  size information in its arguments.  \ccode{esl\_foo\_Deflate(\&obj)}
  frees all the internal memory associated with a \ccode{ESL\_FOO} object,
  given a pointer to the object, but the object shell is left alone.
  The only difference between \ccode{Create,Destroy} and
  \ccode{Inflate,Deflate} is whether the object shell itself is to be
  allocated, or not. Example:

\begin{cchunk}
ESL_SQ  sq;

esl_sq_Inflate(&sq);
esl_sq_Deflate(&sq);
\end{cchunk}



\item [\ccode{Expand,Squeeze}]
   These deal with objects whose contents are not necessarily of a
   fixed size, but can grow and require reallocation of internal data
   fields. A function \ccode{esl\_foo\_Expand()} reallocates an
   \ccode{ESL\_FOO} object to a larger size. Usually, reallocation
   works by doubling the previous allocation. The redoubling strategy
   can result in a fair amount of unused memory overhead (up to
   50\%). A function \ccode{esl\_foo\_Squeeze()} takes a fully-grown
   object and optimizes its memory usage, recovering this wastage
   overhead, on the assumption that no more reallocation will be
   done.



\item [\ccode{Reuse}] 
   \ccode{esl\_foo\_Reuse(obj)} reinitializes an object exactly as a
   \ccode{Create} or \ccode{Inflate} function would initialize it, \emph{without}
   allocating new memory; it reuses memory that has
   already been allocated when the object was originally created or
   inflated. For some objects that are used sequentially (like,
   sequences), reusing one object saves malloc()'s compared to
   lots of Create/Destroy calls. A \ccode{Reuse} function does not
   care whether the object was originally created by a \ccode{Create}
   or a \ccode{Inflate} call. Example:

\begin{cchunk}
ESL_SQ *sq;

sq = esl_sq_Create();
  /* read a sequence into the sq object, have fun with it */

esl_sq_Reuse(sq);
  /* read a second sequence into it */

esl_sq_Destroy(sq);
\end{cchunk}

\end{sreitems}

\subsection{Other common object manipulation functions}

\begin{sreitems}{\ccode{\_Copy(src, dest)}}

\item[\ccode{\_Copy(src, dest)}]
Copies \ccode{src} object into \ccode{dest}, where the caller has
already created the empty \ccode{dest} object. Returns \ccode{ESL\_OK}
on success; throws \ccode{ESL\_EINCOMPAT} if the objects are not
compatible (for example, two matrices that are not the same size).

The order of the arguments is always \ccode{src} $\rightarrow$
\ccode{dest} (unlike the C library's \ccode{strcpy()} convention, which
is the opposite order).

\item[\ccode{\_Duplicate(obj)}] 

Creates and returns a pointer to a duplicate of \ccode{obj}.
Equivalent to (and is a shortcut for) \ccode{dest = \_Create();
\_Copy(src, dest)}. Caller is responsible for free'ing the duplicate
object, just as if it had been \ccode{\_Create}'d. Throws NULL if
allocation fails.

\item[\ccode{\_Set*(obj, value...)}]

Initializes value(s) in \ccode{obj} to \ccode{value}. Special cases of
\ccode{\_Set*} functions may exist, like \ccode{\_SetZero} (set to
zero(s)), or \ccode{esl\_dmatrix\_SetIdentity} (set a dmatrix to an
identity matrix).

\end{sreitems}




\section{Discipline of writing Easel modules}


\subsection{API}

\begin{enumerate}
\item Exposed function names obey Easel conventions.

\item All \ccode{ret\_*} pointers for retrieving info from 
      a function are implemented as optional.

\item On any error (returned or thrown), a function releases any
      memory it has allocated, and all \ccode{ret\_*} pointers are
      \ccode{NULL} or 0, depending on their type.

\item Any function that calls another Easel function must 
      catch any thrown errors. Within Easel, we
      can't assume that the error handler is set to be a fatal
      one.
\end{enumerate}


\subsection{Documentation}

\begin{enumerate}
\item Documentation in .tex files is written to application developers
      (and me); documentation in .c comments is written to Easel
      developers (and me).

\item Every module has a .tex file documenting the module and its API,
      and (if it makes sense) also the particular implementation.

\item Every function exposed to the API can be autodocumented (comment
      header can be converted to \LaTeX) with
      \ccode{autodoc\_functions}, in order to produce appendices
      summarizing the complete Easel function set.
\end{enumerate}


\subsection{Testing}

\begin{enumerate}

\item Every module has a test driver which exercises the API in some
      simple way (and, in the process, provides a ``hello world''
      level example of using the module).

\end{enumerate}











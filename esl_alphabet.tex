The \eslmod{alphabet} module contains routines for digitizing
alphabetic biosequences.

For many purposes, it is more convenient to represent the nucleotides
and amino acids as array indices 0..3 or 0..19, respectively. It is
also convenient to index a sequence as 1..L coordinates instead of C's
0..L-1 array representation, in part for readability, and also because
some codes (DP alignment algorithms, for example) have boundaries
where coordinate 0 is reserved for an initialization condition.

Easel's digital alphabet accommodates gap symbols and IUPAC/IUBMB
degenerate residue nomenclature. It allows "synonymous" letter codes
to map to the same residue (such as allowing T/U to mean the same
thing in nucleic acid sequences, or allowing technically non-IUBMB
codes like the use of X to mean N in DNA sequences, or mapping
modified residues onto the basic alphabet, such as customizing mapping
U (selenocysteine) onto either S (serine) or X (unknown) for different
applications.)

Table~\ref{tbl:alphabet_api} lists the functions in the
\eslmod{alphabet} API.  Easel maintains alphabet information in an
\ccode{ESL\_ALPHABET} structure. An application usually creates its
alphabet once, possibly (but not necessarily) as a global variable.  A
digitized sequence \ccode{dsq} is a \ccode{char *} array of length
$L+2$, where \ccode{dsq[1..L]} are digitized residues, and
\ccode{dsq[0]} and \ccode{dsq[L+1]} are sentinel bytes (of value
\ccode{eslSENTINEL}, 127).

\begin{table}[hbp]
\begin{center}
\begin{tabular}{ll}\hline
   \multicolumn{2}{c}{\textbf{the \ccode{ESL\_ALPHABET} object}}\\
\ccode{esl\_alphabet\_Create()}       & Create alphabet of standard type. \\
\ccode{esl\_alphabet\_CreateCustom()} & Create a custom alphabet. \\
\ccode{esl\_alphabet\_SetSynonym()}   & Define synonymous symbol in custom alphabet. \\
\ccode{esl\_alphabet\_SetCaseInsensitive()} & Make a custom alphabet case insensitive. \\
\ccode{esl\_alphabet\_SetDegeneracy()} & Define degenerate symbol in custom alphabet. \\
   \multicolumn{2}{c}{\textbf{digitized sequences}}\\
\ccode{esl\_dsq\_Create()}       & Allocate and create a new \ccode{dsq}. \\
\ccode{esl\_dsq\_Set()}          & Digitize a sequence into existing \ccode{dsq} space. \\
   \multicolumn{2}{c}{\textbf{other functions}}\\
\ccode{esl\_abc\_{I,F,D}AvgScore()}    & Calculate avg score of degenerate residue.\\
\ccode{esl\_abc\_{I,F,D}ExpectScore()} & Calculate expected score of degenerate residue.\\
\ccode{esl\_abc\_DigitizeSymbol()}     & Returns digital code for one ASCII symbol.\\
\ccode{esl\_abc\_IsBasic()}            & Returns TRUE given code for a fundamental residue.\\
\ccode{esl\_abc\_IsGap()}              & Returns TRUE given code for a gap.\\
\ccode{esl\_abc\_IsDegenerate()}       & Returns TRUE given code for a degeneracy.\\
\hline
\end{tabular}
\end{center}
\caption{The \eslmod{alphabet} API.}
\label{tbl:alphabet_api}
\end{table}

\subsection{An example of using the alphabet API}

Figure~\ref{fig:alphabet_example} shows an example of creating a DNA
alphabet and digitizing a small hardcoded sequence.

\begin{figure}
\input{cexcerpts/alphabet_example}
\caption{An example of using the \eslmod{alphabet} module.}
\label{fig:alphabet_example}
\end{figure}

\begin{itemize}
\item A standard biosequence alphabet is created using
\ccode{esl\_alphabet\_Create(type)}, where \ccode{type} can be
\ccode{eslDNA}, \ccode{eslRNA}, or \ccode{eslAMINO}.

\item An input sequence \ccode{seq} of length \ccode{L} is digitized
according to alphabet \ccode{a}, creating a newly allocated digital
sequence \ccode{dsq}, by calling \ccode{esl\_dsq\_Create(a, seq, L,
\&dsq)}. The caller must free \ccode{dsq} using \ccode{free(dsq)}.
Alternatively, if the caller has already allocated \ccode{L+2} (or
more) bytes in \ccode{dsq}, it can call \ccode{esl\_dsq\_Set(a, seq,
L, dsq)}, which is the non-allocating version of
\ccode{esl\_dsq\_Create()}.

\item For an input sequence of length \ccode{L}, the digitized
sequence \ccode{dsq} is a \ccode{char *} array of \ccode{L+2}
bytes. \ccode{dsq[0]} and \ccode{dsq[L+1]} contain a sentinel byte of
value \ccode{eslSENTINEL} (127).  Positions \ccode{1..L} hold the
residues, where values \ccode{0..3} encode \ccode{ACGT} in DNA
sequences, \ccode{0..3} encode \ccode{ACGU} in RNA sequences, and
\ccode{0..19} encode \ccode{AC..WY} in amino acid sequences.

\item Both sequence-digitizing functions return \ccode{eslEINVAL} if
the input sequence contains characters that are not in the
alphabet. Because input sequences are often provided by a user (not
the program), this is a common error that the application must check
for.
\end{itemize}

\subsection{Standard alphabets: DNA, RNA, protein}

Easel's \emph{internal alphabet} is a string (\ccode{a->sym}) of
length \ccode{Kp}, which contains the \ccode{K} symbols of the base
alphabet, a canonical gap character, (optionally) degenerate residue
codes, and a final, mandatory degeneracy code for ``any residue''.
The digital code used for each residue is the index of a residue in
this string, \ccode{0..Kp-1}.

The three standard internal alphabets are:

\begin{table}[h]
\begin{tabular}{llccrr}
\textbf{Type} & \textbf{sym}                             & Synonyms & gap chars   & \ccode{K} & \ccode{Kp} \\
\ccode{eslDNA}        & \ccode{ACGT-RYMKSWHBVDN}         & U=T; X=N & \ccode{-\_.} & 4         &  16         \\
\ccode{eslRNA}        & \ccode{ACGU-RYMKSWHBVDN}         & T=U; X=N & \ccode{-\_.} & 4         &  16         \\
\ccode{eslAMINO}      & \ccode{ACDEFGHIKLMNPQRSTVWY-BZX} & U=S      & \ccode{-\_.} & 20        &  24         \\
\end{tabular}
\end{table}

The first K residues (\ccode{[0..K-1]}) are the \emph{base alphabet}
(\ccode{ACGT} for DNA, for example).  The next residue (K) is the
canonical gap symbol (\ccode{-} for example). The last residue
\ccode{Kp-1} is the degenerate code for ``any'' or ``unknown''
(\ccode{N}, for example). The remaining residues (\ccode{K+1..Kp-2})
are the \emph{degenerate alphabet}, implementing standard IUPAC or
IUBMB one-letter codes.

The \ccode{sym} string is used to translate digital sequences back to
output sequences for display, so it may be referred to either as the
internal alphabet or the \emph{output alphabet}.  Thus, only the
residues in the \ccode{sym} can be represented in output from Easel.
(An application might still convert some characters for its own
purposes before displaying an alphabetic string; for instance, to use
different gap symbols for insertions versus deletions, or to use
upper/lower case conventions to represent match/insert positions.)

The DNA and RNA alphabets follow published IUBMB recommendations
("Nomenclature for incompletely specified bases in nucleic acid
\citep{IUBMB85}, with the addition of X as a synonym for N
(acquiescing to the BLAST filter standard of using X's to mask
residues), and the use of U in RNA sequences in place of T. (The use of
``synonyms'' is described in the following section on the input map.)

The one-letter code for amino acids follows section 3AA-21 of the
IUPAC recommendations \citep{IUPAC84} augmented by U for
selenocysteine, as recommended in 1999 by the JCBN/NC-IUBMB Newsletter
(\url{http://www.chem.qmul.ac.uk/iubmb/newsletter/1999/item3.html}).

Selenocysteine is an odd case. It is genetically encoded (by UGAs in
unusual contexts), so it is neither a degeneracy nor a synonym. It
would most correctly be treated as part of the base alphabet, but it
is so rare that most applications use a 20-letter alphabet.  Thus, the
default amino acid alphabet maps selenocysteine as a synonym of serine
(S). An application can always define a custom alphabet if it wants to
treat selenocysteine as a base residue. An application might also
choose to customize an alphabet to accept a symbol for pyrrolysine
(the genetically encoded 22nd amino acid, which is only known in a few
proteins and does not yet have an accepted one-letter code) or even
for symbols for the many amino acids generated by posttranslational
modification.


\subsection{Example of creating a custom alphabet}

Figure~\ref{fig:alphabet_example2} shows an example of creating a
customized 21-letter amino acid alphabet that includes the \ccode{U}
selenocysteine code.

\begin{figure}
\input{cexcerpts/alphabet_example2}
\caption{An example of creating a custom alphabet.}
\label{fig:alphabet_example2}
\end{figure}

\subsection{Synonymous residues}

\ccode{esl\_alphabet\_SetSynonym(a, 'U', 'T')} makes an alphabet
interpret \ccode{U} as a \ccode{T} (encoding both as \ccode{3}, in the
case of the standard DNA and RNA alphabets).
 
All three standard alphabets accept \ccode{\_} or \ccode{.}  symbols
as synonyms for the canonical gap symbol \ccode{-}. An application
might want to define additional gap characters, such as \ccode{~}, by
calling \ccode{esl\_alphabet\_SetSynonym(a, '~', '-')} on one of the
standard alphabets to define additional synonyms (you don't have to
create a custom alphabet).

\ccode{esl\_alphabet\_SetCaseInsensitive()} maps both upper case and
lower case input alphabetic characters map to their equivalent in the
internal alphabet in a case-insensitive manner.  This function works
only on residues that have already been declared to be part of the
alphabet, so when defining a custom alphabet, it must be called after
all individual synonyms have been defined. The standard alphabets are
set to be case insensitive.

\subsubsection{Implementation of synonymous residues: the input map}

Internally, an \textbf{input map}, \ccode{a->inmap[0..127]}, specifies
how ASCII text symbol is converted to digital
code. \ccode{a->inmap['T'] = 3} in the standard DNA alphabet, for
example. Synonymous residues are thus easily handled. For example,
\ccode{esl\_alphabet\_SetSynonym(a, 'U', 'T')} sets
\ccode{a->inmap['U'] = a->inmap['T']}. Illegal input characters are
mapped to value \ccode{eslILLEGAL\_CHAR}.


\subsection{Degenerate residues}

When creating a custom alphabet, each degenerate symbol in the
internal alphabet (residues \ccode{K+1}..\ccode{Kp-2}) is initialized
by calling \ccode{esl\_alphabet\_SetDegeneracy(alphabet, c,
syms)}. This assigns degenerate alphabetic symbol \ccode{c} to the
alphabetic symbols in the string \ccode{syms}; for example,
\ccode{esl\_alphabet\_SetDegeneracy(a, 'R', \"AG\")} assigns R
(purine) to mean A or G.  For the standard biosequence alphabets, this
is done automatically to define the IUPAC degeneracy codes for amino
acid residues and the IUBMB degeneracy codes for nucleic acid
residues.  (The last residue, \ccode{Kp-1}, is always the ``any''
character in any alphabet, and it is initialized automatically even in
customized alphabets.)

\subsubsection{Implementation: the degeneracy map}

The alphabet's \textbf{degeneracy map} is implemented in an array
\ccode{a->degen[0..Kp-1][0..K-1]} of 1/0 (TRUE/FALSE) flags.
\ccode{a->degen[x][y] == TRUE} indicates that the residue set $D(x)$
for degeneracy code \ccode{x} contains base residue \ccode{y}.
\ccode{a->ndegen[x]} contains the cardinality $|D(x)|$, how many base
residues are represented by degeneracy code \ccode{x}.

The degeneracy map is undefined for the special case of $x=K$, the
digitized gap symbol.

The last character in the internal alphabet is automatically assumed
to be an ``any'' character (such as 'N' for DNA or RNA, 'X' for
protein), so \ccode{a->degen[Kp-1][i] = 1} for all $i=0..K-1$, and
\ccode{a->ndegen[Kp-1] = K}.

\subsection{Scoring degenerate residues}

To score a degenerate residue code $x$, Easel provides two strategies.
One set of functions assigns an average score:

\[
  S(x) =  \frac{\sum_{y \in D(x)}  S(y) } { |D(x)| },
\]

where $D(x)$ is the set of residues $y$ represented by degeneracy code
$x$ (for example, $D(\mbox{R}) = \{ \mbox{A,G} \}$), $| D(x) |$ is the
number of residues that the degeneracy code includes, and $S(y)$ is
the score of a base residue $y$. Because scores $S(y)$ are commonly
kept as integers, floats, or doubles, depending on the application,
three functions are provided that differ only in the storage type of
the scores: \ccode{esl\_abc\_IAvgScore(a,x,sc)},
\ccode{esl\_abc\_FAvgScore(a,x,sc)}, and
\ccode{esl\_abc\_DAvgScore(a,x,sc)} calculate and return the average
score of residue \ccode{x} in alphabet \ccode{a} given a base score
vector \ccode{sc[0]..sc[K-1]} for integers, floats, and doubles,
respectively.

A second set of functions assigns an expected score, weighted by an
expected occurrence probability $p_y$ of the residues $y$ (often the
random background frequencies):

\[
  S(x) =  \frac{\sum_{y \in D(x)}  p_y S(y) } { \sum_{y \in D(x)} p_y },
\]

These three functions are \ccode{esl\_abc\_IExpectScore(a,x,sc,p)},
\ccode{esl\_abc\_FExpectScore(a,x,sc,p)}, and
\ccode{esl\_abc\_DExpectScore(a,x,sc,p)}.  For the integer and float
versions, the probability vector is in floats; for the double version,
the probability vector is in doubles.

An application might choose to preculate scores for all possible
degenerate codes it might see. HMMER, for example, turns probability
vectors of length \ccode{K} into score residues of length \ccode{Kp}.

An application might also choose to score residues on-the-fly, using
score vectors of length \ccode{K}. Each input residue \ccode{x} would
then have to be tested to see if it is degenerate, before scoring it
appropriately.  \ccode{esl\_abc\_IsBasic(a, x)} returns \ccode{TRUE}
if \ccode{x} is in the basic set of \ccode{K} residues in alphabet
\ccode{a}, and \ccode{FALSE} otherwise. Similarly,
\ccode{esl\_abc\_IsGap(a,x)} tests whether $x$ is a gap, and
\ccode{esl\_abc\_IsDegenerate(a,x)} tests whether $x$ is a degenerate
residue.


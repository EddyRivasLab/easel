\section{Coding conventions}

\subsection{Function naming conventions}

\subsubsection{Object creation, initialization, destruction}

Most of Easel's objects are allocated on the heap; that is, accessed
exclusively via pointers. Less often, routines may allow an object to
be allocated on the stack.

\begin{sreitems}{\ccode{Create,Destroy}}
\item [\ccode{Create,Destroy}] 
  \ccode{esl\_foo\_Create()} allocates and initializes a new \ccode{ESL\_FOO}
  object, returning a pointer to the new
  object. The \ccode{Create()} function is passed any necessary
  initialization or size information in its arguments.
  \ccode{esl\_foo\_Destroy(obj)} frees all the memory associated
  with a \ccode{ESL\_FOO} object,  given a pointer to the object,
  and returns \ccode{ESL\_OK}. Example:

\begin{cchunk}
ESL_SQ *sq;

sq = esl_sq_Create();
esl_sq_Destroy(sq);
\end{cchunk}
  
\item [\ccode{Open,Close}] 
  Same as \ccode{Create()} and \ccode{Destroy()}, but specifically for
  objects associated with input/output streams. Example:

\begin{cchunk}
char        *seqfile = ``foo.seq'';
ESL_SEQFILE *sqfp;

sqfp = esl_seqfile_Open(seqfile);
esl_seqfile_Close(sqfp);
\end{cchunk}

\item [\ccode{Init,Release}]
  \ccode{esl\_foo\_Init(\&obj)} takes a pointer to the ``shell'' of an
  \ccode{ESL\_FOO} object that has been allocated on the stack, and
  allocates and initializes all the internals of it. The
  \ccode{Init()} function is also passed any necessary initialization or
  size information in its arguments.  \ccode{esl\_foo\_Release(\&obj)}
  frees all the internal memory associated with a \ccode{ESL\_FOO} object,
  given a pointer to the object, but the object shell is left alone.
  The only difference between \ccode{Create,Destroy} and
  \ccode{Init,Release} is whether the object shell itself is to be
  allocated, or not. Example:

\begin{cchunk}
ESL_SQ  sq;

esl_sq_Init(&sq);
esl_sq_Release(&sq);
\end{cchunk}


\item [\ccode{Reuse}] 
   \ccode{esl\_foo\_Reuse(obj)} reinitializes an object (exactly as a
   \ccode{Create} or \ccode{Init} function would initialize it), \emph{without}
   allocating new memory; it reuses memory that has
   already been allocated when the object was originally created or
   initialized. For some objects that are used sequentially (like,
   sequences), reusing one object saves malloc()'s compared to
   lots of Create/Destroy calls. A \ccode{Reuse} function does not
   care whether the object was originally created by a \ccode{Create}
   or a \ccode{Init} call. Example:

\begin{cchunk}
ESL_SQ *sq;

sq = esl_sq_Create();
  /* read a sequence into the sq object, have fun with it */
esl_sq_Reuse(sq);
  /* read a second sequence into it */
esl_sq_Destroy(sq);
\end{cchunk}

\end{sreitems}

\subsubsection{Other common object manipulation functions}

\begin{sreitems}{\ccode{\_Copy(src, dest)}}

\item[\ccode{\_Copy(src, dest)}]
Copies \ccode{src} object into \ccode{dest}, where the caller has
already created the empty \ccode{dest} object. Returns \ccode{ESL\_OK}
on success; throws \ccode{ESL\_EINCOMPAT} if the objects are not
compatible (for example, two matrices that are not the same size).

The order of the arguments is always \ccode{src} $\rightarrow$
\ccode{dest} (unlike the C library's \ccode{strcpy()} convention, which
is the opposite order).

\item[\ccode{\_Duplicate(obj)}] 

Creates and returns a pointer to a duplicate of \ccode{obj}.
Equivalent to (and is a shortcut for) \ccode{dest = \_Create();
\_Copy(src, dest)}. Caller is responsible for free'ing the duplicate
object, just as if it had been \ccode{\_Create}'d. Throws NULL if
allocation fails.

\item[\ccode{\_Set*(obj, value...)}]

Initializes value(s) in \ccode{obj} to \ccode{value}. Special cases of
\ccode{\_Set*} functions may exist, like \ccode{\_SetZero} (set to
zero(s)), or \ccode{esl\_dmatrix\_SetIdentity} (set a dmatrix to an
identity matrix).

\end{sreitems}


\subsection{Structured comment conventions}


